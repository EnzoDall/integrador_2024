{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Aluno/Desktop/Nova pasta/integrador_2024/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, InjectionToken, inject, NgZone, ApplicationRef, Injector, createComponent, TemplateRef, Directive, ContentChild, EventEmitter, ViewContainerRef, EnvironmentInjector, Attribute, SkipSelf, Input, Output, reflectComponentType, HostListener, ElementRef, ViewChild } from '@angular/core';\nimport * as i3 from '@angular/router';\nimport { NavigationStart, PRIMARY_OUTLET, ChildrenOutletContexts, ActivatedRoute, Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, componentOnReady } from '@ionic/core/components';\nimport { Subject, fromEvent, BehaviorSubject, combineLatest, of } from 'rxjs';\nimport { __decorate } from 'tslib';\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\nimport { NgControl } from '@angular/forms';\nconst _c0 = [\"tabsInner\"];\nclass MenuController {\n  menuController;\n  constructor(menuController) {\n    this.menuController = menuController;\n  }\n  /**\r\n   * Programmatically open the Menu.\r\n   * @param [menuId]  Optionally get the menu by its id, or side.\r\n   * @return returns a promise when the menu is fully opened\r\n   */\n  open(menuId) {\n    return this.menuController.open(menuId);\n  }\n  /**\r\n   * Programmatically close the Menu. If no `menuId` is given as the first\r\n   * argument then it'll close any menu which is open. If a `menuId`\r\n   * is given then it'll close that exact menu.\r\n   * @param [menuId]  Optionally get the menu by its id, or side.\r\n   * @return returns a promise when the menu is fully closed\r\n   */\n  close(menuId) {\n    return this.menuController.close(menuId);\n  }\n  /**\r\n   * Toggle the menu. If it's closed, it will open, and if opened, it\r\n   * will close.\r\n   * @param [menuId]  Optionally get the menu by its id, or side.\r\n   * @return returns a promise when the menu has been toggled\r\n   */\n  toggle(menuId) {\n    return this.menuController.toggle(menuId);\n  }\n  /**\r\n   * Used to enable or disable a menu. For example, there could be multiple\r\n   * left menus, but only one of them should be able to be opened at the same\r\n   * time. If there are multiple menus on the same side, then enabling one menu\r\n   * will also automatically disable all the others that are on the same side.\r\n   * @param [menuId]  Optionally get the menu by its id, or side.\r\n   * @return Returns the instance of the menu, which is useful for chaining.\r\n   */\n  enable(shouldEnable, menuId) {\n    return this.menuController.enable(shouldEnable, menuId);\n  }\n  /**\r\n   * Used to enable or disable the ability to swipe open the menu.\r\n   * @param shouldEnable  True if it should be swipe-able, false if not.\r\n   * @param [menuId]  Optionally get the menu by its id, or side.\r\n   * @return Returns the instance of the menu, which is useful for chaining.\r\n   */\n  swipeGesture(shouldEnable, menuId) {\n    return this.menuController.swipeGesture(shouldEnable, menuId);\n  }\n  /**\r\n   * @param [menuId] Optionally get the menu by its id, or side.\r\n   * @return Returns true if the specified menu is currently open, otherwise false.\r\n   * If the menuId is not specified, it returns true if ANY menu is currenly open.\r\n   */\n  isOpen(menuId) {\n    return this.menuController.isOpen(menuId);\n  }\n  /**\r\n   * @param [menuId]  Optionally get the menu by its id, or side.\r\n   * @return Returns true if the menu is currently enabled, otherwise false.\r\n   */\n  isEnabled(menuId) {\n    return this.menuController.isEnabled(menuId);\n  }\n  /**\r\n   * Used to get a menu instance. If a `menuId` is not provided then it'll\r\n   * return the first menu found. If a `menuId` is `left` or `right`, then\r\n   * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\r\n   * provided, then it'll try to find the menu using the menu's `id`\r\n   * property. If a menu is not found then it'll return `null`.\r\n   * @param [menuId]  Optionally get the menu by its id, or side.\r\n   * @return Returns the instance of the menu if found, otherwise `null`.\r\n   */\n  get(menuId) {\n    return this.menuController.get(menuId);\n  }\n  /**\r\n   * @return Returns the instance of the menu already opened, otherwise `null`.\r\n   */\n  getOpen() {\n    return this.menuController.getOpen();\n  }\n  /**\r\n   * @return Returns an array of all menu instances.\r\n   */\n  getMenus() {\n    return this.menuController.getMenus();\n  }\n  registerAnimation(name, animation) {\n    return this.menuController.registerAnimation(name, animation);\n  }\n  isAnimating() {\n    return this.menuController.isAnimating();\n  }\n  _getOpenSync() {\n    return this.menuController._getOpenSync();\n  }\n  _createAnimation(type, menuCmp) {\n    return this.menuController._createAnimation(type, menuCmp);\n  }\n  _register(menu) {\n    return this.menuController._register(menu);\n  }\n  _unregister(menu) {\n    return this.menuController._unregister(menu);\n  }\n  _setOpen(menu, shouldOpen, animated) {\n    return this.menuController._setOpen(menu, shouldOpen, animated);\n  }\n}\nclass DomController {\n  /**\r\n   * Schedules a task to run during the READ phase of the next frame.\r\n   * This task should only read the DOM, but never modify it.\r\n   */\n  read(cb) {\n    getQueue().read(cb);\n  }\n  /**\r\n   * Schedules a task to run during the WRITE phase of the next frame.\r\n   * This task should write the DOM, but never READ it.\r\n   */\n  write(cb) {\n    getQueue().write(cb);\n  }\n  /** @nocollapse */\n  static ɵfac = function DomController_Factory(t) {\n    return new (t || DomController)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DomController,\n    factory: DomController.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DomController, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nconst getQueue = () => {\n  const win = typeof window !== 'undefined' ? window : null;\n  if (win != null) {\n    const Ionic = win.Ionic;\n    if (Ionic?.queue) {\n      return Ionic.queue;\n    }\n    return {\n      read: cb => win.requestAnimationFrame(cb),\n      write: cb => win.requestAnimationFrame(cb)\n    };\n  }\n  return {\n    read: cb => cb(),\n    write: cb => cb()\n  };\n};\nclass Platform {\n  doc;\n  _readyPromise;\n  win;\n  /**\r\n   * @hidden\r\n   */\n  backButton = new Subject();\n  /**\r\n   * The keyboardDidShow event emits when the\r\n   * on-screen keyboard is presented.\r\n   */\n  keyboardDidShow = new Subject();\n  /**\r\n   * The keyboardDidHide event emits when the\r\n   * on-screen keyboard is hidden.\r\n   */\n  keyboardDidHide = new Subject();\n  /**\r\n   * The pause event emits when the native platform puts the application\r\n   * into the background, typically when the user switches to a different\r\n   * application. This event would emit when a Cordova app is put into\r\n   * the background, however, it would not fire on a standard web browser.\r\n   */\n  pause = new Subject();\n  /**\r\n   * The resume event emits when the native platform pulls the application\r\n   * out from the background. This event would emit when a Cordova app comes\r\n   * out from the background, however, it would not fire on a standard web browser.\r\n   */\n  resume = new Subject();\n  /**\r\n   * The resize event emits when the browser window has changed dimensions. This\r\n   * could be from a browser window being physically resized, or from a device\r\n   * changing orientation.\r\n   */\n  resize = new Subject();\n  constructor(doc, zone) {\n    this.doc = doc;\n    zone.run(() => {\n      this.win = doc.defaultView;\n      this.backButton.subscribeWithPriority = function (priority, callback) {\n        return this.subscribe(ev => {\n          return ev.register(priority, processNextHandler => zone.run(() => callback(processNextHandler)));\n        });\n      };\n      proxyEvent(this.pause, doc, 'pause', zone);\n      proxyEvent(this.resume, doc, 'resume', zone);\n      proxyEvent(this.backButton, doc, 'ionBackButton', zone);\n      proxyEvent(this.resize, this.win, 'resize', zone);\n      proxyEvent(this.keyboardDidShow, this.win, 'ionKeyboardDidShow', zone);\n      proxyEvent(this.keyboardDidHide, this.win, 'ionKeyboardDidHide', zone);\n      let readyResolve;\n      this._readyPromise = new Promise(res => {\n        readyResolve = res;\n      });\n      if (this.win?.['cordova']) {\n        doc.addEventListener('deviceready', () => {\n          readyResolve('cordova');\n        }, {\n          once: true\n        });\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        readyResolve('dom');\n      }\n    });\n  }\n  /**\r\n   * @returns returns true/false based on platform.\r\n   * @description\r\n   * Depending on the platform the user is on, `is(platformName)` will\r\n   * return `true` or `false`. Note that the same app can return `true`\r\n   * for more than one platform name. For example, an app running from\r\n   * an iPad would return `true` for the platform names: `mobile`,\r\n   * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\r\n   * from Cordova then `cordova` would be true, and if it was running\r\n   * from a web browser on the iPad then `mobileweb` would be `true`.\r\n   *\r\n   * ```\r\n   * import { Platform } from 'ionic-angular';\r\n   *\r\n   * @Component({...})\r\n   * export MyPage {\r\n   *   constructor(public platform: Platform) {\r\n   *     if (this.platform.is('ios')) {\r\n   *       // This will only print when on iOS\r\n   *       console.log('I am an iOS device!');\r\n   *     }\r\n   *   }\r\n   * }\r\n   * ```\r\n   *\r\n   * | Platform Name   | Description                        |\r\n   * |-----------------|------------------------------------|\r\n   * | android         | on a device running Android.       |\r\n   * | capacitor       | on a device running Capacitor.     |\r\n   * | cordova         | on a device running Cordova.       |\r\n   * | ios             | on a device running iOS.           |\r\n   * | ipad            | on an iPad device.                 |\r\n   * | iphone          | on an iPhone device.               |\r\n   * | phablet         | on a phablet device.               |\r\n   * | tablet          | on a tablet device.                |\r\n   * | electron        | in Electron on a desktop device.   |\r\n   * | pwa             | as a PWA app.                      |\r\n   * | mobile          | on a mobile device.                |\r\n   * | mobileweb       | on a mobile device in a browser.   |\r\n   * | desktop         | on a desktop device.               |\r\n   * | hybrid          | is a cordova or capacitor app.     |\r\n   *\r\n   */\n  is(platformName) {\n    return isPlatform(this.win, platformName);\n  }\n  /**\r\n   * @returns the array of platforms\r\n   * @description\r\n   * Depending on what device you are on, `platforms` can return multiple values.\r\n   * Each possible value is a hierarchy of platforms. For example, on an iPhone,\r\n   * it would return `mobile`, `ios`, and `iphone`.\r\n   *\r\n   * ```\r\n   * import { Platform } from 'ionic-angular';\r\n   *\r\n   * @Component({...})\r\n   * export MyPage {\r\n   *   constructor(public platform: Platform) {\r\n   *     // This will print an array of the current platforms\r\n   *     console.log(this.platform.platforms());\r\n   *   }\r\n   * }\r\n   * ```\r\n   */\n  platforms() {\n    return getPlatforms(this.win);\n  }\n  /**\r\n   * Returns a promise when the platform is ready and native functionality\r\n   * can be called. If the app is running from within a web browser, then\r\n   * the promise will resolve when the DOM is ready. When the app is running\r\n   * from an application engine such as Cordova, then the promise will\r\n   * resolve when Cordova triggers the `deviceready` event.\r\n   *\r\n   * The resolved value is the `readySource`, which states which platform\r\n   * ready was used. For example, when Cordova is ready, the resolved ready\r\n   * source is `cordova`. The default ready source value will be `dom`. The\r\n   * `readySource` is useful if different logic should run depending on the\r\n   * platform the app is running from. For example, only Cordova can execute\r\n   * the status bar plugin, so the web should not run status bar plugin logic.\r\n   *\r\n   * ```\r\n   * import { Component } from '@angular/core';\r\n   * import { Platform } from 'ionic-angular';\r\n   *\r\n   * @Component({...})\r\n   * export MyApp {\r\n   *   constructor(public platform: Platform) {\r\n   *     this.platform.ready().then((readySource) => {\r\n   *       console.log('Platform ready from', readySource);\r\n   *       // Platform now ready, execute any required native code\r\n   *     });\r\n   *   }\r\n   * }\r\n   * ```\r\n   */\n  ready() {\n    return this._readyPromise;\n  }\n  /**\r\n   * Returns if this app is using right-to-left language direction or not.\r\n   * We recommend the app's `index.html` file already has the correct `dir`\r\n   * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\r\n   * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\r\n   */\n  get isRTL() {\n    return this.doc.dir === 'rtl';\n  }\n  /**\r\n   * Get the query string parameter\r\n   */\n  getQueryParam(key) {\n    return readQueryParam(this.win.location.href, key);\n  }\n  /**\r\n   * Returns `true` if the app is in landscape mode.\r\n   */\n  isLandscape() {\n    return !this.isPortrait();\n  }\n  /**\r\n   * Returns `true` if the app is in portrait mode.\r\n   */\n  isPortrait() {\n    return this.win.matchMedia?.('(orientation: portrait)').matches;\n  }\n  testUserAgent(expression) {\n    const nav = this.win.navigator;\n    return !!(nav?.userAgent && nav.userAgent.indexOf(expression) >= 0);\n  }\n  /**\r\n   * Get the current url.\r\n   */\n  url() {\n    return this.win.location.href;\n  }\n  /**\r\n   * Gets the width of the platform's viewport using `window.innerWidth`.\r\n   */\n  width() {\n    return this.win.innerWidth;\n  }\n  /**\r\n   * Gets the height of the platform's viewport using `window.innerHeight`.\r\n   */\n  height() {\n    return this.win.innerHeight;\n  }\n  /** @nocollapse */\n  static ɵfac = function Platform_Factory(t) {\n    return new (t || Platform)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i0.NgZone));\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Platform,\n    factory: Platform.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Platform, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: i0.NgZone\n    }];\n  }, null);\n})();\nconst readQueryParam = (url, key) => {\n  key = key.replace(/[[\\]\\\\]/g, '\\\\$&');\n  const regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\n  const results = regex.exec(url);\n  return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\n};\nconst proxyEvent = (emitter, el, eventName, zone) => {\n  if (el) {\n    el.addEventListener(eventName, ev => {\n      /**\r\n       * `zone.run` is required to make sure that we are running inside the Angular zone\r\n       * at all times. This is necessary since an app that has Capacitor will\r\n       * override the `document.addEventListener` with its own implementation.\r\n       * The override causes the event to no longer be in the Angular zone.\r\n       */\n      zone.run(() => {\n        // ?? cordova might emit \"null\" events\n        const value = ev != null ? ev.detail : undefined;\n        emitter.next(value);\n      });\n    });\n  }\n};\nclass NavController {\n  location;\n  serializer;\n  router;\n  topOutlet;\n  direction = DEFAULT_DIRECTION;\n  animated = DEFAULT_ANIMATED;\n  animationBuilder;\n  guessDirection = 'forward';\n  guessAnimation;\n  lastNavId = -1;\n  constructor(platform, location, serializer, router) {\n    this.location = location;\n    this.serializer = serializer;\n    this.router = router;\n    // Subscribe to router events to detect direction\n    if (router) {\n      router.events.subscribe(ev => {\n        if (ev instanceof NavigationStart) {\n          // restoredState is set if the browser back/forward button is used\n          const id = ev.restoredState ? ev.restoredState.navigationId : ev.id;\n          this.guessDirection = this.guessAnimation = id < this.lastNavId ? 'back' : 'forward';\n          this.lastNavId = this.guessDirection === 'forward' ? ev.id : id;\n        }\n      });\n    }\n    // Subscribe to backButton events\n    platform.backButton.subscribeWithPriority(0, processNextHandler => {\n      this.pop();\n      processNextHandler();\n    });\n  }\n  /**\r\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\r\n   * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\r\n   *\r\n   * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\r\n   * and that it will show a \"forward\" animation by default.\r\n   *\r\n   * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\r\n   *\r\n   * ```html\r\n   * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\r\n   * ```\r\n   */\n  navigateForward(url, options = {}) {\n    this.setDirection('forward', options.animated, options.animationDirection, options.animation);\n    return this.navigate(url, options);\n  }\n  /**\r\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\r\n   * it's equivalent to calling:\r\n   *\r\n   * ```ts\r\n   * this.navController.setDirection('back');\r\n   * this.router.navigateByUrl(path);\r\n   * ```\r\n   *\r\n   * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\r\n   * and that it will show a \"back\" animation by default.\r\n   *\r\n   * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\r\n   *\r\n   * ```html\r\n   * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\r\n   * ```\r\n   */\n  navigateBack(url, options = {}) {\n    this.setDirection('back', options.animated, options.animationDirection, options.animation);\n    return this.navigate(url, options);\n  }\n  /**\r\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\r\n   * it's equivalent to calling:\r\n   *\r\n   * ```ts\r\n   * this.navController.setDirection('root');\r\n   * this.router.navigateByUrl(path);\r\n   * ```\r\n   *\r\n   * Going **root** means that all existing pages in the stack will be removed,\r\n   * and the navigated page will become the single page in the stack.\r\n   *\r\n   * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\r\n   *\r\n   * ```html\r\n   * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\r\n   * ```\r\n   */\n  navigateRoot(url, options = {}) {\n    this.setDirection('root', options.animated, options.animationDirection, options.animation);\n    return this.navigate(url, options);\n  }\n  /**\r\n   * Same as [Location](https://angular.io/api/common/Location)'s back() method.\r\n   * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\r\n   * by default.\r\n   */\n  back(options = {\n    animated: true,\n    animationDirection: 'back'\n  }) {\n    this.setDirection('back', options.animated, options.animationDirection, options.animation);\n    return this.location.back();\n  }\n  /**\r\n   * This methods goes back in the context of Ionic's stack navigation.\r\n   *\r\n   * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\r\n   * This is the recommended way to go back when you are using `ion-router-outlet`.\r\n   *\r\n   * Resolves to `true` if it was able to pop.\r\n   */\n  pop() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let outlet = _this.topOutlet;\n      while (outlet) {\n        if (yield outlet.pop()) {\n          return true;\n        } else {\n          outlet = outlet.parentOutlet;\n        }\n      }\n      return false;\n    })();\n  }\n  /**\r\n   * This methods specifies the direction of the next navigation performed by the Angular router.\r\n   *\r\n   * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\r\n   *\r\n   * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\r\n   */\n  setDirection(direction, animated, animationDirection, animationBuilder) {\n    this.direction = direction;\n    this.animated = getAnimation(direction, animated, animationDirection);\n    this.animationBuilder = animationBuilder;\n  }\n  /**\r\n   * @internal\r\n   */\n  setTopOutlet(outlet) {\n    this.topOutlet = outlet;\n  }\n  /**\r\n   * @internal\r\n   */\n  consumeTransition() {\n    let direction = 'root';\n    let animation;\n    const animationBuilder = this.animationBuilder;\n    if (this.direction === 'auto') {\n      direction = this.guessDirection;\n      animation = this.guessAnimation;\n    } else {\n      animation = this.animated;\n      direction = this.direction;\n    }\n    this.direction = DEFAULT_DIRECTION;\n    this.animated = DEFAULT_ANIMATED;\n    this.animationBuilder = undefined;\n    return {\n      direction,\n      animation,\n      animationBuilder\n    };\n  }\n  navigate(url, options) {\n    if (Array.isArray(url)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.router.navigate(url, options);\n    } else {\n      /**\r\n       * navigateByUrl ignores any properties that\r\n       * would change the url, so things like queryParams\r\n       * would be ignored unless we create a url tree\r\n       * More Info: https://github.com/angular/angular/issues/18798\r\n       */\n      const urlTree = this.serializer.parse(url.toString());\n      if (options.queryParams !== undefined) {\n        urlTree.queryParams = {\n          ...options.queryParams\n        };\n      }\n      if (options.fragment !== undefined) {\n        urlTree.fragment = options.fragment;\n      }\n      /**\r\n       * `navigateByUrl` will still apply `NavigationExtras` properties\r\n       * that do not modify the url, such as `replaceUrl` which is why\r\n       * `options` is passed in here.\r\n       */\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.router.navigateByUrl(urlTree, options);\n    }\n  }\n  /** @nocollapse */\n  static ɵfac = function NavController_Factory(t) {\n    return new (t || NavController)(i0.ɵɵinject(Platform), i0.ɵɵinject(i1.Location), i0.ɵɵinject(i3.UrlSerializer), i0.ɵɵinject(i3.Router, 8));\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavController,\n    factory: NavController.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NavController, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Platform\n    }, {\n      type: i1.Location\n    }, {\n      type: i3.UrlSerializer\n    }, {\n      type: i3.Router,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\nconst getAnimation = (direction, animated, animationDirection) => {\n  if (animated === false) {\n    return undefined;\n  }\n  if (animationDirection !== undefined) {\n    return animationDirection;\n  }\n  if (direction === 'forward' || direction === 'back') {\n    return direction;\n  } else if (direction === 'root' && animated === true) {\n    return 'forward';\n  }\n  return undefined;\n};\nconst DEFAULT_DIRECTION = 'auto';\nconst DEFAULT_ANIMATED = undefined;\nclass Config {\n  get(key, fallback) {\n    const c = getConfig();\n    if (c) {\n      return c.get(key, fallback);\n    }\n    return null;\n  }\n  getBoolean(key, fallback) {\n    const c = getConfig();\n    if (c) {\n      return c.getBoolean(key, fallback);\n    }\n    return false;\n  }\n  getNumber(key, fallback) {\n    const c = getConfig();\n    if (c) {\n      return c.getNumber(key, fallback);\n    }\n    return 0;\n  }\n  /** @nocollapse */\n  static ɵfac = function Config_Factory(t) {\n    return new (t || Config)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Config,\n    factory: Config.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Config, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nconst ConfigToken = new InjectionToken('USERCONFIG');\nconst getConfig = () => {\n  if (typeof window !== 'undefined') {\n    const Ionic = window.Ionic;\n    if (Ionic?.config) {\n      return Ionic.config;\n    }\n  }\n  return null;\n};\n\n/**\r\n * @description\r\n * NavParams are an object that exists on a page and can contain data for that particular view.\r\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\r\n * option with a simple `get` method.\r\n *\r\n * @usage\r\n * ```ts\r\n * import { NavParams } from '@ionic/angular';\r\n *\r\n * export class MyClass{\r\n *\r\n *  constructor(navParams: NavParams){\r\n *    // userParams is an object we have in our nav-parameters\r\n *    navParams.get('userParams');\r\n *  }\r\n *\r\n * }\r\n * ```\r\n */\nclass NavParams {\n  data;\n  constructor(data = {}) {\n    this.data = data;\n  }\n  /**\r\n   * Get the value of a nav-parameter for the current view\r\n   *\r\n   * ```ts\r\n   * import { NavParams } from 'ionic-angular';\r\n   *\r\n   * export class MyClass{\r\n   *  constructor(public navParams: NavParams){\r\n   *    // userParams is an object we have in our nav-parameters\r\n   *    this.navParams.get('userParams');\r\n   *  }\r\n   * }\r\n   * ```\r\n   *\r\n   * @param param Which param you want to look up\r\n   */\n  get(param) {\n    return this.data[param];\n  }\n}\n\n// TODO(FW-2827): types\nclass AngularDelegate {\n  zone = inject(NgZone);\n  applicationRef = inject(ApplicationRef);\n  create(environmentInjector, injector, elementReferenceKey) {\n    return new AngularFrameworkDelegate(environmentInjector, injector, this.applicationRef, this.zone, elementReferenceKey);\n  }\n  /** @nocollapse */\n  static ɵfac = function AngularDelegate_Factory(t) {\n    return new (t || AngularDelegate)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularDelegate,\n    factory: AngularDelegate.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularDelegate, [{\n    type: Injectable\n  }], null, null);\n})();\nclass AngularFrameworkDelegate {\n  environmentInjector;\n  injector;\n  applicationRef;\n  zone;\n  elementReferenceKey;\n  elRefMap = new WeakMap();\n  elEventsMap = new WeakMap();\n  constructor(environmentInjector, injector, applicationRef, zone, elementReferenceKey) {\n    this.environmentInjector = environmentInjector;\n    this.injector = injector;\n    this.applicationRef = applicationRef;\n    this.zone = zone;\n    this.elementReferenceKey = elementReferenceKey;\n  }\n  attachViewToDom(container, component, params, cssClasses) {\n    return this.zone.run(() => {\n      return new Promise(resolve => {\n        const componentProps = {\n          ...params\n        };\n        /**\r\n         * Ionic Angular passes a reference to a modal\r\n         * or popover that can be accessed using a\r\n         * variable in the overlay component. If\r\n         * elementReferenceKey is defined, then we should\r\n         * pass a reference to the component using\r\n         * elementReferenceKey as the key.\r\n         */\n        if (this.elementReferenceKey !== undefined) {\n          componentProps[this.elementReferenceKey] = container;\n        }\n        const el = attachView(this.zone, this.environmentInjector, this.injector, this.applicationRef, this.elRefMap, this.elEventsMap, container, component, componentProps, cssClasses, this.elementReferenceKey);\n        resolve(el);\n      });\n    });\n  }\n  removeViewFromDom(_container, component) {\n    return this.zone.run(() => {\n      return new Promise(resolve => {\n        const componentRef = this.elRefMap.get(component);\n        if (componentRef) {\n          componentRef.destroy();\n          this.elRefMap.delete(component);\n          const unbindEvents = this.elEventsMap.get(component);\n          if (unbindEvents) {\n            unbindEvents();\n            this.elEventsMap.delete(component);\n          }\n        }\n        resolve();\n      });\n    });\n  }\n}\nconst attachView = (zone, environmentInjector, injector, applicationRef, elRefMap, elEventsMap, container, component, params, cssClasses, elementReferenceKey) => {\n  /**\r\n   * Wraps the injector with a custom injector that\r\n   * provides NavParams to the component.\r\n   *\r\n   * NavParams is a legacy feature from Ionic v3 that allows\r\n   * Angular developers to provide data to a component\r\n   * and access it by providing NavParams as a dependency\r\n   * in the constructor.\r\n   *\r\n   * The modern approach is to access the data directly\r\n   * from the component's class instance.\r\n   */\n  const childInjector = Injector.create({\n    providers: getProviders(params),\n    parent: injector\n  });\n  const componentRef = createComponent(component, {\n    environmentInjector,\n    elementInjector: childInjector\n  });\n  const instance = componentRef.instance;\n  const hostElement = componentRef.location.nativeElement;\n  if (params) {\n    /**\r\n     * For modals and popovers, a reference to the component is\r\n     * added to `params` during the call to attachViewToDom. If\r\n     * a reference using this name is already set, this means\r\n     * the app is trying to use the name as a component prop,\r\n     * which will cause collisions.\r\n     */\n    if (elementReferenceKey && instance[elementReferenceKey] !== undefined) {\n      console.error(`[Ionic Error]: ${elementReferenceKey} is a reserved property when using ${container.tagName.toLowerCase()}. Rename or remove the \"${elementReferenceKey}\" property from ${component.name}.`);\n    }\n    Object.assign(instance, params);\n  }\n  if (cssClasses) {\n    for (const cssClass of cssClasses) {\n      hostElement.classList.add(cssClass);\n    }\n  }\n  const unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\n  container.appendChild(hostElement);\n  applicationRef.attachView(componentRef.hostView);\n  elRefMap.set(hostElement, componentRef);\n  elEventsMap.set(hostElement, unbindEvents);\n  return hostElement;\n};\nconst LIFECYCLES = [LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD];\nconst bindLifecycleEvents = (zone, instance, element) => {\n  return zone.run(() => {\n    const unregisters = LIFECYCLES.filter(eventName => typeof instance[eventName] === 'function').map(eventName => {\n      const handler = ev => instance[eventName](ev.detail);\n      element.addEventListener(eventName, handler);\n      return () => element.removeEventListener(eventName, handler);\n    });\n    return () => unregisters.forEach(fn => fn());\n  });\n};\nconst NavParamsToken = new InjectionToken('NavParamsToken');\nconst getProviders = params => {\n  return [{\n    provide: NavParamsToken,\n    useValue: params\n  }, {\n    provide: NavParams,\n    useFactory: provideNavParamsInjectable,\n    deps: [NavParamsToken]\n  }];\n};\nconst provideNavParamsInjectable = params => {\n  return new NavParams(params);\n};\n\n// TODO: Is there a way we can grab this from angular-component-lib instead?\n/* eslint-disable */\n/* tslint:disable */\nconst proxyInputs = (Cmp, inputs) => {\n  const Prototype = Cmp.prototype;\n  inputs.forEach(item => {\n    Object.defineProperty(Prototype, item, {\n      get() {\n        return this.el[item];\n      },\n      set(val) {\n        this.z.runOutsideAngular(() => this.el[item] = val);\n      }\n    });\n  });\n};\nconst proxyMethods = (Cmp, methods) => {\n  const Prototype = Cmp.prototype;\n  methods.forEach(methodName => {\n    Prototype[methodName] = function () {\n      const args = arguments;\n      return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));\n    };\n  });\n};\nconst proxyOutputs = (instance, el, events) => {\n  events.forEach(eventName => instance[eventName] = fromEvent(el, eventName));\n};\n// tslint:disable-next-line: only-arrow-functions\nfunction ProxyCmp(opts) {\n  const decorator = function (cls) {\n    const {\n      defineCustomElementFn,\n      inputs,\n      methods\n    } = opts;\n    if (defineCustomElementFn !== undefined) {\n      defineCustomElementFn();\n    }\n    if (inputs) {\n      proxyInputs(cls, inputs);\n    }\n    if (methods) {\n      proxyMethods(cls, methods);\n    }\n    return cls;\n  };\n  return decorator;\n}\nconst POPOVER_INPUTS = ['alignment', 'animated', 'arrow', 'keepContentsMounted', 'backdropDismiss', 'cssClass', 'dismissOnSelect', 'enterAnimation', 'event', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop', 'translucent', 'trigger', 'triggerAction', 'reference', 'size', 'side'];\nconst POPOVER_METHODS = ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss'];\nlet IonPopover = class IonPopover {\n  z;\n  // TODO(FW-2827): type\n  template;\n  isCmpOpen = false;\n  el;\n  constructor(c, r, z) {\n    this.z = z;\n    this.el = r.nativeElement;\n    this.el.addEventListener('ionMount', () => {\n      this.isCmpOpen = true;\n      c.detectChanges();\n    });\n    this.el.addEventListener('didDismiss', () => {\n      this.isCmpOpen = false;\n      c.detectChanges();\n    });\n    proxyOutputs(this, this.el, ['ionPopoverDidPresent', 'ionPopoverWillPresent', 'ionPopoverWillDismiss', 'ionPopoverDidDismiss', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n  }\n  /** @nocollapse */\n  static ɵfac = function IonPopover_Factory(t) {\n    return new (t || IonPopover)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IonPopover,\n    selectors: [[\"ion-popover\"]],\n    contentQueries: function IonPopover_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      alignment: \"alignment\",\n      animated: \"animated\",\n      arrow: \"arrow\",\n      keepContentsMounted: \"keepContentsMounted\",\n      backdropDismiss: \"backdropDismiss\",\n      cssClass: \"cssClass\",\n      dismissOnSelect: \"dismissOnSelect\",\n      enterAnimation: \"enterAnimation\",\n      event: \"event\",\n      isOpen: \"isOpen\",\n      keyboardClose: \"keyboardClose\",\n      leaveAnimation: \"leaveAnimation\",\n      mode: \"mode\",\n      showBackdrop: \"showBackdrop\",\n      translucent: \"translucent\",\n      trigger: \"trigger\",\n      triggerAction: \"triggerAction\",\n      reference: \"reference\",\n      size: \"size\",\n      side: \"side\"\n    }\n  });\n};\nIonPopover = __decorate([ProxyCmp({\n  inputs: POPOVER_INPUTS,\n  methods: POPOVER_METHODS\n})\n/**\r\n * @Component extends from @Directive\r\n * so by defining the inputs here we\r\n * do not need to re-define them for the\r\n * lazy loaded popover.\r\n */], IonPopover);\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IonPopover, [{\n    type: Directive,\n    args: [{\n      selector: 'ion-popover',\n      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n      inputs: POPOVER_INPUTS\n    }]\n  }], function () {\n    return [{\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    template: [{\n      type: ContentChild,\n      args: [TemplateRef, {\n        static: false\n      }]\n    }]\n  });\n})();\nconst MODAL_INPUTS = ['animated', 'keepContentsMounted', 'backdropBreakpoint', 'backdropDismiss', 'breakpoints', 'canDismiss', 'cssClass', 'enterAnimation', 'event', 'handle', 'handleBehavior', 'initialBreakpoint', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'presentingElement', 'showBackdrop', 'translucent', 'trigger'];\nconst MODAL_METHODS = ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss', 'setCurrentBreakpoint', 'getCurrentBreakpoint'];\nlet IonModal = class IonModal {\n  z;\n  // TODO(FW-2827): type\n  template;\n  isCmpOpen = false;\n  el;\n  constructor(c, r, z) {\n    this.z = z;\n    this.el = r.nativeElement;\n    this.el.addEventListener('ionMount', () => {\n      this.isCmpOpen = true;\n      c.detectChanges();\n    });\n    this.el.addEventListener('didDismiss', () => {\n      this.isCmpOpen = false;\n      c.detectChanges();\n    });\n    proxyOutputs(this, this.el, ['ionModalDidPresent', 'ionModalWillPresent', 'ionModalWillDismiss', 'ionModalDidDismiss', 'ionBreakpointDidChange', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n  }\n  /** @nocollapse */\n  static ɵfac = function IonModal_Factory(t) {\n    return new (t || IonModal)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IonModal,\n    selectors: [[\"ion-modal\"]],\n    contentQueries: function IonModal_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      animated: \"animated\",\n      keepContentsMounted: \"keepContentsMounted\",\n      backdropBreakpoint: \"backdropBreakpoint\",\n      backdropDismiss: \"backdropDismiss\",\n      breakpoints: \"breakpoints\",\n      canDismiss: \"canDismiss\",\n      cssClass: \"cssClass\",\n      enterAnimation: \"enterAnimation\",\n      event: \"event\",\n      handle: \"handle\",\n      handleBehavior: \"handleBehavior\",\n      initialBreakpoint: \"initialBreakpoint\",\n      isOpen: \"isOpen\",\n      keyboardClose: \"keyboardClose\",\n      leaveAnimation: \"leaveAnimation\",\n      mode: \"mode\",\n      presentingElement: \"presentingElement\",\n      showBackdrop: \"showBackdrop\",\n      translucent: \"translucent\",\n      trigger: \"trigger\"\n    }\n  });\n};\nIonModal = __decorate([ProxyCmp({\n  inputs: MODAL_INPUTS,\n  methods: MODAL_METHODS\n})\n/**\r\n * @Component extends from @Directive\r\n * so by defining the inputs here we\r\n * do not need to re-define them for the\r\n * lazy loaded popover.\r\n */], IonModal);\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IonModal, [{\n    type: Directive,\n    args: [{\n      selector: 'ion-modal',\n      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n      inputs: MODAL_INPUTS\n    }]\n  }], function () {\n    return [{\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    template: [{\n      type: ContentChild,\n      args: [TemplateRef, {\n        static: false\n      }]\n    }]\n  });\n})();\nconst insertView = (views, view, direction) => {\n  if (direction === 'root') {\n    return setRoot(views, view);\n  } else if (direction === 'forward') {\n    return setForward(views, view);\n  } else {\n    return setBack(views, view);\n  }\n};\nconst setRoot = (views, view) => {\n  views = views.filter(v => v.stackId !== view.stackId);\n  views.push(view);\n  return views;\n};\nconst setForward = (views, view) => {\n  const index = views.indexOf(view);\n  if (index >= 0) {\n    views = views.filter(v => v.stackId !== view.stackId || v.id <= view.id);\n  } else {\n    views.push(view);\n  }\n  return views;\n};\nconst setBack = (views, view) => {\n  const index = views.indexOf(view);\n  if (index >= 0) {\n    return views.filter(v => v.stackId !== view.stackId || v.id <= view.id);\n  } else {\n    return setRoot(views, view);\n  }\n};\nconst getUrl = (router, activatedRoute) => {\n  const urlTree = router.createUrlTree(['.'], {\n    relativeTo: activatedRoute\n  });\n  return router.serializeUrl(urlTree);\n};\nconst isTabSwitch = (enteringView, leavingView) => {\n  if (!leavingView) {\n    return true;\n  }\n  return enteringView.stackId !== leavingView.stackId;\n};\nconst computeStackId = (prefixUrl, url) => {\n  if (!prefixUrl) {\n    return undefined;\n  }\n  const segments = toSegments(url);\n  for (let i = 0; i < segments.length; i++) {\n    if (i >= prefixUrl.length) {\n      return segments[i];\n    }\n    if (segments[i] !== prefixUrl[i]) {\n      return undefined;\n    }\n  }\n  return undefined;\n};\nconst toSegments = path => {\n  return path.split('/').map(s => s.trim()).filter(s => s !== '');\n};\nconst destroyView = view => {\n  if (view) {\n    view.ref.destroy();\n    view.unlistenEvents();\n  }\n};\n\n// TODO(FW-2827): types\nclass StackController {\n  containerEl;\n  router;\n  navCtrl;\n  zone;\n  location;\n  views = [];\n  runningTask;\n  skipTransition = false;\n  tabsPrefix;\n  activeView;\n  nextId = 0;\n  constructor(tabsPrefix, containerEl, router, navCtrl, zone, location) {\n    this.containerEl = containerEl;\n    this.router = router;\n    this.navCtrl = navCtrl;\n    this.zone = zone;\n    this.location = location;\n    this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\n  }\n  createView(ref, activatedRoute) {\n    const url = getUrl(this.router, activatedRoute);\n    const element = ref?.location?.nativeElement;\n    const unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\n    return {\n      id: this.nextId++,\n      stackId: computeStackId(this.tabsPrefix, url),\n      unlistenEvents,\n      element,\n      ref,\n      url\n    };\n  }\n  getExistingView(activatedRoute) {\n    const activatedUrlKey = getUrl(this.router, activatedRoute);\n    const view = this.views.find(vw => vw.url === activatedUrlKey);\n    if (view) {\n      view.ref.changeDetectorRef.reattach();\n    }\n    return view;\n  }\n  setActive(enteringView) {\n    const consumeResult = this.navCtrl.consumeTransition();\n    let {\n      direction,\n      animation,\n      animationBuilder\n    } = consumeResult;\n    const leavingView = this.activeView;\n    const tabSwitch = isTabSwitch(enteringView, leavingView);\n    if (tabSwitch) {\n      direction = 'back';\n      animation = undefined;\n    }\n    const viewsSnapshot = this.views.slice();\n    let currentNavigation;\n    const router = this.router;\n    // Angular >= 7.2.0\n    if (router.getCurrentNavigation) {\n      currentNavigation = router.getCurrentNavigation();\n      // Angular < 7.2.0\n    } else if (router.navigations?.value) {\n      currentNavigation = router.navigations.value;\n    }\n    /**\r\n     * If the navigation action\r\n     * sets `replaceUrl: true`\r\n     * then we need to make sure\r\n     * we remove the last item\r\n     * from our views stack\r\n     */\n    if (currentNavigation?.extras?.replaceUrl) {\n      if (this.views.length > 0) {\n        this.views.splice(-1, 1);\n      }\n    }\n    const reused = this.views.includes(enteringView);\n    const views = this.insertView(enteringView, direction);\n    // Trigger change detection before transition starts\n    // This will call ngOnInit() the first time too, just after the view\n    // was attached to the dom, but BEFORE the transition starts\n    if (!reused) {\n      enteringView.ref.changeDetectorRef.detectChanges();\n    }\n    /**\r\n     * If we are going back from a page that\r\n     * was presented using a custom animation\r\n     * we should default to using that\r\n     * unless the developer explicitly\r\n     * provided another animation.\r\n     */\n    const customAnimation = enteringView.animationBuilder;\n    if (animationBuilder === undefined && direction === 'back' && !tabSwitch && customAnimation !== undefined) {\n      animationBuilder = customAnimation;\n    }\n    /**\r\n     * Save any custom animation so that navigating\r\n     * back will use this custom animation by default.\r\n     */\n    if (leavingView) {\n      leavingView.animationBuilder = animationBuilder;\n    }\n    // Wait until previous transitions finish\n    return this.zone.runOutsideAngular(() => {\n      return this.wait(() => {\n        // disconnect leaving page from change detection to\n        // reduce jank during the page transition\n        if (leavingView) {\n          leavingView.ref.changeDetectorRef.detach();\n        }\n        // In case the enteringView is the same as the leavingPage we need to reattach()\n        enteringView.ref.changeDetectorRef.reattach();\n        return this.transition(enteringView, leavingView, animation, this.canGoBack(1), false, animationBuilder).then(() => cleanupAsync(enteringView, views, viewsSnapshot, this.location, this.zone)).then(() => ({\n          enteringView,\n          direction,\n          animation,\n          tabSwitch\n        }));\n      });\n    });\n  }\n  canGoBack(deep, stackId = this.getActiveStackId()) {\n    return this.getStack(stackId).length > deep;\n  }\n  pop(deep, stackId = this.getActiveStackId()) {\n    return this.zone.run(() => {\n      const views = this.getStack(stackId);\n      if (views.length <= deep) {\n        return Promise.resolve(false);\n      }\n      const view = views[views.length - deep - 1];\n      let url = view.url;\n      const viewSavedData = view.savedData;\n      if (viewSavedData) {\n        const primaryOutlet = viewSavedData.get('primary');\n        if (primaryOutlet?.route?._routerState?.snapshot.url) {\n          url = primaryOutlet.route._routerState.snapshot.url;\n        }\n      }\n      const {\n        animationBuilder\n      } = this.navCtrl.consumeTransition();\n      return this.navCtrl.navigateBack(url, {\n        ...view.savedExtras,\n        animation: animationBuilder\n      }).then(() => true);\n    });\n  }\n  startBackTransition() {\n    const leavingView = this.activeView;\n    if (leavingView) {\n      const views = this.getStack(leavingView.stackId);\n      const enteringView = views[views.length - 2];\n      const customAnimation = enteringView.animationBuilder;\n      return this.wait(() => {\n        return this.transition(enteringView,\n        // entering view\n        leavingView,\n        // leaving view\n        'back', this.canGoBack(2), true, customAnimation);\n      });\n    }\n    return Promise.resolve();\n  }\n  endBackTransition(shouldComplete) {\n    if (shouldComplete) {\n      this.skipTransition = true;\n      this.pop(1);\n    } else if (this.activeView) {\n      cleanup(this.activeView, this.views, this.views, this.location, this.zone);\n    }\n  }\n  getLastUrl(stackId) {\n    const views = this.getStack(stackId);\n    return views.length > 0 ? views[views.length - 1] : undefined;\n  }\n  /**\r\n   * @internal\r\n   */\n  getRootUrl(stackId) {\n    const views = this.getStack(stackId);\n    return views.length > 0 ? views[0] : undefined;\n  }\n  getActiveStackId() {\n    return this.activeView ? this.activeView.stackId : undefined;\n  }\n  /**\r\n   * @internal\r\n   */\n  getActiveView() {\n    return this.activeView;\n  }\n  hasRunningTask() {\n    return this.runningTask !== undefined;\n  }\n  destroy() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.containerEl = undefined;\n    this.views.forEach(destroyView);\n    this.activeView = undefined;\n    this.views = [];\n  }\n  getStack(stackId) {\n    return this.views.filter(v => v.stackId === stackId);\n  }\n  insertView(enteringView, direction) {\n    this.activeView = enteringView;\n    this.views = insertView(this.views, enteringView, direction);\n    return this.views.slice();\n  }\n  transition(enteringView, leavingView, direction, showGoBack, progressAnimation, animationBuilder) {\n    if (this.skipTransition) {\n      this.skipTransition = false;\n      return Promise.resolve(false);\n    }\n    if (leavingView === enteringView) {\n      return Promise.resolve(false);\n    }\n    const enteringEl = enteringView ? enteringView.element : undefined;\n    const leavingEl = leavingView ? leavingView.element : undefined;\n    const containerEl = this.containerEl;\n    if (enteringEl && enteringEl !== leavingEl) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n      if (containerEl.commit) {\n        return containerEl.commit(enteringEl, leavingEl, {\n          duration: direction === undefined ? 0 : undefined,\n          direction,\n          showGoBack,\n          progressAnimation,\n          animationBuilder\n        });\n      }\n    }\n    return Promise.resolve(false);\n  }\n  wait(task) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.runningTask !== undefined) {\n        yield _this2.runningTask;\n        _this2.runningTask = undefined;\n      }\n      const promise = _this2.runningTask = task();\n      promise.finally(() => _this2.runningTask = undefined);\n      return promise;\n    })();\n  }\n}\nconst cleanupAsync = (activeRoute, views, viewsSnapshot, location, zone) => {\n  if (typeof requestAnimationFrame === 'function') {\n    return new Promise(resolve => {\n      requestAnimationFrame(() => {\n        cleanup(activeRoute, views, viewsSnapshot, location, zone);\n        resolve();\n      });\n    });\n  }\n  return Promise.resolve();\n};\nconst cleanup = (activeRoute, views, viewsSnapshot, location, zone) => {\n  /**\r\n   * Re-enter the Angular zone when destroying page components. This will allow\r\n   * lifecycle events (`ngOnDestroy`) to be run inside the Angular zone.\r\n   */\n  zone.run(() => viewsSnapshot.filter(view => !views.includes(view)).forEach(destroyView));\n  views.forEach(view => {\n    /**\r\n     * In the event that a user navigated multiple\r\n     * times in rapid succession, we want to make sure\r\n     * we don't pre-emptively detach a view while\r\n     * it is in mid-transition.\r\n     *\r\n     * In this instance we also do not care about query\r\n     * params or fragments as it will be the same view regardless\r\n     */\n    const locationWithoutParams = location.path().split('?')[0];\n    const locationWithoutFragment = locationWithoutParams.split('#')[0];\n    if (view !== activeRoute && view.url !== locationWithoutFragment) {\n      const element = view.element;\n      element.setAttribute('aria-hidden', 'true');\n      element.classList.add('ion-page-hidden');\n      view.ref.changeDetectorRef.detach();\n    }\n  });\n};\n\n// TODO(FW-2827): types\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nclass IonRouterOutlet {\n  parentOutlet;\n  nativeEl;\n  activatedView = null;\n  tabsPrefix;\n  _swipeGesture;\n  stackCtrl;\n  // Maintain map of activated route proxies for each component instance\n  proxyMap = new WeakMap();\n  // Keep the latest activated route in a subject for the proxy routes to switch map to\n  currentActivatedRoute$ = new BehaviorSubject(null);\n  activated = null;\n  /** @internal */\n  get activatedComponentRef() {\n    return this.activated;\n  }\n  _activatedRoute = null;\n  /**\r\n   * The name of the outlet\r\n   */\n  name = PRIMARY_OUTLET;\n  /** @internal */\n  stackWillChange = new EventEmitter();\n  /** @internal */\n  stackDidChange = new EventEmitter();\n  // eslint-disable-next-line @angular-eslint/no-output-rename\n  activateEvents = new EventEmitter();\n  // eslint-disable-next-line @angular-eslint/no-output-rename\n  deactivateEvents = new EventEmitter();\n  parentContexts = inject(ChildrenOutletContexts);\n  location = inject(ViewContainerRef);\n  environmentInjector = inject(EnvironmentInjector);\n  inputBinder = inject(INPUT_BINDER, {\n    optional: true\n  });\n  /** @nodoc */\n  supportsBindingToComponentInputs = true;\n  // Ionic providers\n  config = inject(Config);\n  navCtrl = inject(NavController);\n  set animation(animation) {\n    this.nativeEl.animation = animation;\n  }\n  set animated(animated) {\n    this.nativeEl.animated = animated;\n  }\n  set swipeGesture(swipe) {\n    this._swipeGesture = swipe;\n    this.nativeEl.swipeHandler = swipe ? {\n      canStart: () => this.stackCtrl.canGoBack(1) && !this.stackCtrl.hasRunningTask(),\n      onStart: () => this.stackCtrl.startBackTransition(),\n      onEnd: shouldContinue => this.stackCtrl.endBackTransition(shouldContinue)\n    } : undefined;\n  }\n  constructor(name, tabs, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n    this.parentOutlet = parentOutlet;\n    this.nativeEl = elementRef.nativeElement;\n    this.name = name || PRIMARY_OUTLET;\n    this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\n    this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, this.navCtrl, zone, commonLocation);\n    this.parentContexts.onChildOutletCreated(this.name, this);\n  }\n  ngOnDestroy() {\n    this.stackCtrl.destroy();\n    this.inputBinder?.unsubscribeFromRouteData(this);\n  }\n  getContext() {\n    return this.parentContexts.getContext(this.name);\n  }\n  ngOnInit() {\n    this.initializeOutletWithName();\n  }\n  // Note: Ionic deviates from the Angular Router implementation here\n  initializeOutletWithName() {\n    if (!this.activated) {\n      // If the outlet was not instantiated at the time the route got activated we need to populate\n      // the outlet when it is initialized (ie inside a NgIf)\n      const context = this.getContext();\n      if (context?.route) {\n        this.activateWith(context.route, context.injector);\n      }\n    }\n    new Promise(resolve => componentOnReady(this.nativeEl, resolve)).then(() => {\n      if (this._swipeGesture === undefined) {\n        this.swipeGesture = this.config.getBoolean('swipeBackEnabled', this.nativeEl.mode === 'ios');\n      }\n    });\n  }\n  get isActivated() {\n    return !!this.activated;\n  }\n  get component() {\n    if (!this.activated) {\n      throw new Error('Outlet is not activated');\n    }\n    return this.activated.instance;\n  }\n  get activatedRoute() {\n    if (!this.activated) {\n      throw new Error('Outlet is not activated');\n    }\n    return this._activatedRoute;\n  }\n  get activatedRouteData() {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n  /**\r\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\r\n   */\n  detach() {\n    throw new Error('incompatible reuse strategy');\n  }\n  /**\r\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attach(_ref, _activatedRoute) {\n    throw new Error('incompatible reuse strategy');\n  }\n  deactivate() {\n    if (this.activated) {\n      if (this.activatedView) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const context = this.getContext();\n        this.activatedView.savedData = new Map(context.children['contexts']);\n        /**\r\n         * Angular v11.2.10 introduced a change\r\n         * where this route context is cleared out when\r\n         * a router-outlet is deactivated, However,\r\n         * we need this route information in order to\r\n         * return a user back to the correct tab when\r\n         * leaving and then going back to the tab context.\r\n         */\n        const primaryOutlet = this.activatedView.savedData.get('primary');\n        if (primaryOutlet && context.route) {\n          primaryOutlet.route = {\n            ...context.route\n          };\n        }\n        /**\r\n         * Ensure we are saving the NavigationExtras\r\n         * data otherwise it will be lost\r\n         */\n        this.activatedView.savedExtras = {};\n        if (context.route) {\n          const contextSnapshot = context.route.snapshot;\n          this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\n          this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\n        }\n      }\n      const c = this.component;\n      this.activatedView = null;\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n  activateWith(activatedRoute, environmentInjector) {\n    if (this.isActivated) {\n      throw new Error('Cannot activate an already activated outlet');\n    }\n    this._activatedRoute = activatedRoute;\n    let cmpRef;\n    let enteringView = this.stackCtrl.getExistingView(activatedRoute);\n    if (enteringView) {\n      cmpRef = this.activated = enteringView.ref;\n      const saved = enteringView.savedData;\n      if (saved) {\n        // self-restore\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const context = this.getContext();\n        context.children['contexts'] = saved;\n      }\n      // Updated activated route proxy for this component\n      this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\n    } else {\n      const snapshot = activatedRoute._futureSnapshot;\n      /**\r\n       * Angular 14 introduces a new `loadComponent` property to the route config.\r\n       * This function will assign a `component` property to the route snapshot.\r\n       * We check for the presence of this property to determine if the route is\r\n       * using standalone components.\r\n       */\n      const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n      // We create an activated route proxy object that will maintain future updates for this component\n      // over its lifecycle in the stack.\n      const component$ = new BehaviorSubject(null);\n      const activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\n      const injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const component = snapshot.routeConfig.component ?? snapshot.component;\n      /**\r\n       * View components need to be added as a child of ion-router-outlet\r\n       * for page transitions and swipe to go back.\r\n       * However, createComponent mounts components as siblings of the\r\n       * ViewContainerRef. As a result, outletContent must reference\r\n       * an ng-container inside of ion-router-outlet and not\r\n       * ion-router-outlet itself.\r\n       */\n      cmpRef = this.activated = this.outletContent.createComponent(component, {\n        index: this.outletContent.length,\n        injector,\n        environmentInjector: environmentInjector ?? this.environmentInjector\n      });\n      // Once the component is created we can push it to our local subject supplied to the proxy\n      component$.next(cmpRef.instance);\n      // Calling `markForCheck` to make sure we will run the change detection when the\n      // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n      /**\r\n       * At this point this.activated has been set earlier\r\n       * in this function, so it is guaranteed to be non-null.\r\n       */\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      enteringView = this.stackCtrl.createView(this.activated, activatedRoute);\n      // Store references to the proxy by component\n      this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\n      this.currentActivatedRoute$.next({\n        component: cmpRef.instance,\n        activatedRoute\n      });\n    }\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.activatedView = enteringView;\n    /**\r\n     * The top outlet is set prior to the entering view's transition completing,\r\n     * so that when we have nested outlets (e.g. ion-tabs inside an ion-router-outlet),\r\n     * the tabs outlet will be assigned as the top outlet when a view inside tabs is\r\n     * activated.\r\n     *\r\n     * In this scenario, activeWith is called for both the tabs and the root router outlet.\r\n     * To avoid a race condition, we assign the top outlet synchronously.\r\n     */\n    this.navCtrl.setTopOutlet(this);\n    const leavingView = this.stackCtrl.getActiveView();\n    this.stackWillChange.emit({\n      enteringView,\n      tabSwitch: isTabSwitch(enteringView, leavingView)\n    });\n    this.stackCtrl.setActive(enteringView).then(data => {\n      this.activateEvents.emit(cmpRef.instance);\n      this.stackDidChange.emit(data);\n    });\n  }\n  /**\r\n   * Returns `true` if there are pages in the stack to go back.\r\n   */\n  canGoBack(deep = 1, stackId) {\n    return this.stackCtrl.canGoBack(deep, stackId);\n  }\n  /**\r\n   * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\r\n   */\n  pop(deep = 1, stackId) {\n    return this.stackCtrl.pop(deep, stackId);\n  }\n  /**\r\n   * Returns the URL of the active page of each stack.\r\n   */\n  getLastUrl(stackId) {\n    const active = this.stackCtrl.getLastUrl(stackId);\n    return active ? active.url : undefined;\n  }\n  /**\r\n   * Returns the RouteView of the active page of each stack.\r\n   * @internal\r\n   */\n  getLastRouteView(stackId) {\n    return this.stackCtrl.getLastUrl(stackId);\n  }\n  /**\r\n   * Returns the root view in the tab stack.\r\n   * @internal\r\n   */\n  getRootView(stackId) {\n    return this.stackCtrl.getRootUrl(stackId);\n  }\n  /**\r\n   * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\r\n   */\n  getActiveStackId() {\n    return this.stackCtrl.getActiveStackId();\n  }\n  /**\r\n   * Since the activated route can change over the life time of a component in an ion router outlet, we create\r\n   * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\r\n   */\n  createActivatedRouteProxy(component$, activatedRoute) {\n    const proxy = new ActivatedRoute();\n    proxy._futureSnapshot = activatedRoute._futureSnapshot;\n    proxy._routerState = activatedRoute._routerState;\n    proxy.snapshot = activatedRoute.snapshot;\n    proxy.outlet = activatedRoute.outlet;\n    proxy.component = activatedRoute.component;\n    // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\n    proxy._paramMap = this.proxyObservable(component$, 'paramMap');\n    proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\n    proxy.url = this.proxyObservable(component$, 'url');\n    proxy.params = this.proxyObservable(component$, 'params');\n    proxy.queryParams = this.proxyObservable(component$, 'queryParams');\n    proxy.fragment = this.proxyObservable(component$, 'fragment');\n    proxy.data = this.proxyObservable(component$, 'data');\n    return proxy;\n  }\n  /**\r\n   * Create a wrapped observable that will switch to the latest activated route matched by the given component\r\n   */\n  proxyObservable(component$, path) {\n    return component$.pipe(\n    // First wait until the component instance is pushed\n    filter(component => !!component), switchMap(component => this.currentActivatedRoute$.pipe(filter(current => current !== null && current.component === component), switchMap(current => current && current.activatedRoute[path]), distinctUntilChanged())));\n  }\n  /**\r\n   * Updates the activated route proxy for the given component to the new incoming router state\r\n   */\n  updateActivatedRouteProxy(component, activatedRoute) {\n    const proxy = this.proxyMap.get(component);\n    if (!proxy) {\n      throw new Error(`Could not find activated route proxy for view`);\n    }\n    proxy._futureSnapshot = activatedRoute._futureSnapshot;\n    proxy._routerState = activatedRoute._routerState;\n    proxy.snapshot = activatedRoute.snapshot;\n    proxy.outlet = activatedRoute.outlet;\n    proxy.component = activatedRoute.component;\n    this.currentActivatedRoute$.next({\n      component,\n      activatedRoute\n    });\n  }\n  /** @nocollapse */\n  static ɵfac = function IonRouterOutlet_Factory(t) {\n    return new (t || IonRouterOutlet)(i0.ɵɵinjectAttribute('name'), i0.ɵɵinjectAttribute('tabs'), i0.ɵɵdirectiveInject(i1.Location), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.ActivatedRoute), i0.ɵɵdirectiveInject(IonRouterOutlet, 12));\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IonRouterOutlet,\n    selectors: [[\"ion-router-outlet\"]],\n    inputs: {\n      animated: \"animated\",\n      animation: \"animation\",\n      mode: \"mode\",\n      swipeGesture: \"swipeGesture\",\n      name: \"name\"\n    },\n    outputs: {\n      stackWillChange: \"stackWillChange\",\n      stackDidChange: \"stackDidChange\",\n      activateEvents: \"activate\",\n      deactivateEvents: \"deactivate\"\n    },\n    exportAs: [\"outlet\"]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IonRouterOutlet, [{\n    type: Directive,\n    args: [{\n      selector: 'ion-router-outlet',\n      exportAs: 'outlet',\n      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n      inputs: ['animated', 'animation', 'mode', 'swipeGesture']\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Attribute,\n        args: ['name']\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Attribute,\n        args: ['tabs']\n      }]\n    }, {\n      type: i1.Location\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i3.Router\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i3.ActivatedRoute\n    }, {\n      type: IonRouterOutlet,\n      decorators: [{\n        type: SkipSelf\n      }, {\n        type: Optional\n      }]\n    }];\n  }, {\n    name: [{\n      type: Input\n    }],\n    stackWillChange: [{\n      type: Output\n    }],\n    stackDidChange: [{\n      type: Output\n    }],\n    activateEvents: [{\n      type: Output,\n      args: ['activate']\n    }],\n    deactivateEvents: [{\n      type: Output,\n      args: ['deactivate']\n    }]\n  });\n})();\nclass OutletInjector {\n  route;\n  childContexts;\n  parent;\n  constructor(route, childContexts, parent) {\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n  get(token, notFoundValue) {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n    return this.parent.get(token, notFoundValue);\n  }\n}\n// TODO: FW-4785 - Remove this once Angular 15 support is dropped\nconst INPUT_BINDER = new InjectionToken('');\n/**\r\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\r\n * inputs.\r\n *\r\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\r\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\r\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\r\n * Importantly, when an input does not have an item in the route data with a matching key, this\r\n * input is set to `undefined`. If it were not done this way, the previous information would be\r\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\r\n *\r\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\r\n * the subscriptions are cleaned up.\r\n */\nclass RoutedComponentInputBinder {\n  outletDataSubscriptions = new Map();\n  bindActivatedRouteToOutletComponent(outlet) {\n    this.unsubscribeFromRouteData(outlet);\n    this.subscribeToRouteData(outlet);\n  }\n  unsubscribeFromRouteData(outlet) {\n    this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n    this.outletDataSubscriptions.delete(outlet);\n  }\n  subscribeToRouteData(outlet) {\n    const {\n      activatedRoute\n    } = outlet;\n    const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index) => {\n      data = {\n        ...queryParams,\n        ...params,\n        ...data\n      };\n      // Get the first result from the data subscription synchronously so it's available to\n      // the component as soon as possible (and doesn't require a second change detection).\n      if (index === 0) {\n        return of(data);\n      }\n      // Promise.resolve is used to avoid synchronously writing the wrong data when\n      // two of the Observables in the `combineLatest` stream emit one after\n      // another.\n      return Promise.resolve(data);\n    })).subscribe(data => {\n      // Outlet may have been deactivated or changed names to be associated with a different\n      // route\n      if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {\n        this.unsubscribeFromRouteData(outlet);\n        return;\n      }\n      const mirror = reflectComponentType(activatedRoute.component);\n      if (!mirror) {\n        this.unsubscribeFromRouteData(outlet);\n        return;\n      }\n      for (const {\n        templateName\n      } of mirror.inputs) {\n        outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n      }\n    });\n    this.outletDataSubscriptions.set(outlet, dataSubscription);\n  }\n  /** @nocollapse */\n  static ɵfac = function RoutedComponentInputBinder_Factory(t) {\n    return new (t || RoutedComponentInputBinder)();\n  };\n  /** @nocollapse */\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RoutedComponentInputBinder,\n    factory: RoutedComponentInputBinder.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RoutedComponentInputBinder, [{\n    type: Injectable\n  }], null, null);\n})();\nconst provideComponentInputBinding = () => {\n  return {\n    provide: INPUT_BINDER,\n    useFactory: componentInputBindingFactory,\n    deps: [Router]\n  };\n};\nfunction componentInputBindingFactory(router) {\n  /**\r\n   * We cast the router to any here, since the componentInputBindingEnabled\r\n   * property is not available until Angular v16.\r\n   */\n  if (router?.componentInputBindingEnabled) {\n    return new RoutedComponentInputBinder();\n  }\n  return null;\n}\nconst BACK_BUTTON_INPUTS = ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'routerAnimation', 'text', 'type'];\nlet IonBackButton = class IonBackButton {\n  routerOutlet;\n  navCtrl;\n  config;\n  r;\n  z;\n  el;\n  constructor(routerOutlet, navCtrl, config, r, z, c) {\n    this.routerOutlet = routerOutlet;\n    this.navCtrl = navCtrl;\n    this.config = config;\n    this.r = r;\n    this.z = z;\n    c.detach();\n    this.el = this.r.nativeElement;\n  }\n  /**\r\n   * @internal\r\n   */\n  onClick(ev) {\n    const defaultHref = this.defaultHref || this.config.get('backButtonDefaultHref');\n    if (this.routerOutlet?.canGoBack()) {\n      this.navCtrl.setDirection('back', undefined, undefined, this.routerAnimation);\n      this.routerOutlet.pop();\n      ev.preventDefault();\n    } else if (defaultHref != null) {\n      this.navCtrl.navigateBack(defaultHref, {\n        animation: this.routerAnimation\n      });\n      ev.preventDefault();\n    }\n  }\n  /** @nocollapse */\n  static ɵfac = function IonBackButton_Factory(t) {\n    return new (t || IonBackButton)(i0.ɵɵdirectiveInject(IonRouterOutlet, 8), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(Config), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IonBackButton,\n    hostBindings: function IonBackButton_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IonBackButton_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      color: \"color\",\n      defaultHref: \"defaultHref\",\n      disabled: \"disabled\",\n      icon: \"icon\",\n      mode: \"mode\",\n      routerAnimation: \"routerAnimation\",\n      text: \"text\",\n      type: \"type\"\n    }\n  });\n};\nIonBackButton = __decorate([ProxyCmp({\n  inputs: BACK_BUTTON_INPUTS\n})], IonBackButton);\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IonBackButton, [{\n    type: Directive,\n    args: [{\n      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n      inputs: BACK_BUTTON_INPUTS\n    }]\n  }], function () {\n    return [{\n      type: IonRouterOutlet,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: NavController\n    }, {\n      type: Config\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.ChangeDetectorRef\n    }];\n  }, {\n    onClick: [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }]\n  });\n})();\n\n/**\r\n * Adds support for Ionic routing directions and animations to the base Angular router link directive.\r\n *\r\n * When the router link is clicked, the directive will assign the direction and\r\n * animation so that the routing integration will transition correctly.\r\n */\nclass RouterLinkDelegateDirective {\n  locationStrategy;\n  navCtrl;\n  elementRef;\n  router;\n  routerLink;\n  routerDirection = 'forward';\n  routerAnimation;\n  constructor(locationStrategy, navCtrl, elementRef, router, routerLink) {\n    this.locationStrategy = locationStrategy;\n    this.navCtrl = navCtrl;\n    this.elementRef = elementRef;\n    this.router = router;\n    this.routerLink = routerLink;\n  }\n  ngOnInit() {\n    this.updateTargetUrlAndHref();\n  }\n  ngOnChanges() {\n    this.updateTargetUrlAndHref();\n  }\n  updateTargetUrlAndHref() {\n    if (this.routerLink?.urlTree) {\n      const href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n      this.elementRef.nativeElement.href = href;\n    }\n  }\n  /**\r\n   * @internal\r\n   */\n  onClick(ev) {\n    this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n    /**\r\n     * This prevents the browser from\r\n     * performing a page reload when pressing\r\n     * an Ionic component with routerLink.\r\n     * The page reload interferes with routing\r\n     * and causes ion-back-button to disappear\r\n     * since the local history is wiped on reload.\r\n     */\n    ev.preventDefault();\n  }\n  /** @nocollapse */\n  static ɵfac = function RouterLinkDelegateDirective_Factory(t) {\n    return new (t || RouterLinkDelegateDirective)(i0.ɵɵdirectiveInject(i1.LocationStrategy), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i3.RouterLink, 8));\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RouterLinkDelegateDirective,\n    selectors: [[\"\", \"routerLink\", \"\", 5, \"a\", 5, \"area\"]],\n    hostBindings: function RouterLinkDelegateDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function RouterLinkDelegateDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      routerDirection: \"routerDirection\",\n      routerAnimation: \"routerAnimation\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RouterLinkDelegateDirective, [{\n    type: Directive,\n    args: [{\n      selector: ':not(a):not(area)[routerLink]'\n    }]\n  }], function () {\n    return [{\n      type: i1.LocationStrategy\n    }, {\n      type: NavController\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i3.Router\n    }, {\n      type: i3.RouterLink,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    routerDirection: [{\n      type: Input\n    }],\n    routerAnimation: [{\n      type: Input\n    }],\n    onClick: [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }]\n  });\n})();\nclass RouterLinkWithHrefDelegateDirective {\n  locationStrategy;\n  navCtrl;\n  elementRef;\n  router;\n  routerLink;\n  routerDirection = 'forward';\n  routerAnimation;\n  constructor(locationStrategy, navCtrl, elementRef, router, routerLink) {\n    this.locationStrategy = locationStrategy;\n    this.navCtrl = navCtrl;\n    this.elementRef = elementRef;\n    this.router = router;\n    this.routerLink = routerLink;\n  }\n  ngOnInit() {\n    this.updateTargetUrlAndHref();\n  }\n  ngOnChanges() {\n    this.updateTargetUrlAndHref();\n  }\n  updateTargetUrlAndHref() {\n    if (this.routerLink?.urlTree) {\n      const href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n      this.elementRef.nativeElement.href = href;\n    }\n  }\n  /**\r\n   * @internal\r\n   */\n  onClick() {\n    this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n  }\n  /** @nocollapse */\n  static ɵfac = function RouterLinkWithHrefDelegateDirective_Factory(t) {\n    return new (t || RouterLinkWithHrefDelegateDirective)(i0.ɵɵdirectiveInject(i1.LocationStrategy), i0.ɵɵdirectiveInject(NavController), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i3.RouterLink, 8));\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RouterLinkWithHrefDelegateDirective,\n    selectors: [[\"a\", \"routerLink\", \"\"], [\"area\", \"routerLink\", \"\"]],\n    hostBindings: function RouterLinkWithHrefDelegateDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function RouterLinkWithHrefDelegateDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      routerDirection: \"routerDirection\",\n      routerAnimation: \"routerAnimation\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RouterLinkWithHrefDelegateDirective, [{\n    type: Directive,\n    args: [{\n      selector: 'a[routerLink],area[routerLink]'\n    }]\n  }], function () {\n    return [{\n      type: i1.LocationStrategy\n    }, {\n      type: NavController\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i3.Router\n    }, {\n      type: i3.RouterLink,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    routerDirection: [{\n      type: Input\n    }],\n    routerAnimation: [{\n      type: Input\n    }],\n    onClick: [{\n      type: HostListener,\n      args: ['click']\n    }]\n  });\n})();\nconst NAV_INPUTS = ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'];\nconst NAV_METHODS = ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious'];\nlet IonNav = class IonNav {\n  z;\n  el;\n  constructor(ref, environmentInjector, injector, angularDelegate, z, c) {\n    this.z = z;\n    c.detach();\n    this.el = ref.nativeElement;\n    ref.nativeElement.delegate = angularDelegate.create(environmentInjector, injector);\n    proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);\n  }\n  /** @nocollapse */\n  static ɵfac = function IonNav_Factory(t) {\n    return new (t || IonNav)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.EnvironmentInjector), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(AngularDelegate), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IonNav,\n    inputs: {\n      animated: \"animated\",\n      animation: \"animation\",\n      root: \"root\",\n      rootParams: \"rootParams\",\n      swipeGesture: \"swipeGesture\"\n    }\n  });\n};\nIonNav = __decorate([ProxyCmp({\n  inputs: NAV_INPUTS,\n  methods: NAV_METHODS\n})], IonNav);\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IonNav, [{\n    type: Directive,\n    args: [{\n      // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\n      inputs: NAV_INPUTS\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.EnvironmentInjector\n    }, {\n      type: i0.Injector\n    }, {\n      type: AngularDelegate\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.ChangeDetectorRef\n    }];\n  }, null);\n})();\n\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nclass IonTabs {\n  navCtrl;\n  tabsInner;\n  /**\r\n   * Emitted before the tab view is changed.\r\n   */\n  ionTabsWillChange = new EventEmitter();\n  /**\r\n   * Emitted after the tab view is changed.\r\n   */\n  ionTabsDidChange = new EventEmitter();\n  tabBarSlot = 'bottom';\n  constructor(navCtrl) {\n    this.navCtrl = navCtrl;\n  }\n  ngAfterContentInit() {\n    this.detectSlotChanges();\n  }\n  ngAfterContentChecked() {\n    this.detectSlotChanges();\n  }\n  /**\r\n   * @internal\r\n   */\n  onStackWillChange({\n    enteringView,\n    tabSwitch\n  }) {\n    const stackId = enteringView.stackId;\n    if (tabSwitch && stackId !== undefined) {\n      this.ionTabsWillChange.emit({\n        tab: stackId\n      });\n    }\n  }\n  /**\r\n   * @internal\r\n   */\n  onStackDidChange({\n    enteringView,\n    tabSwitch\n  }) {\n    const stackId = enteringView.stackId;\n    if (tabSwitch && stackId !== undefined) {\n      if (this.tabBar) {\n        this.tabBar.selectedTab = stackId;\n      }\n      this.ionTabsDidChange.emit({\n        tab: stackId\n      });\n    }\n  }\n  /**\r\n   * When a tab button is clicked, there are several scenarios:\r\n   * 1. If the selected tab is currently active (the tab button has been clicked\r\n   *    again), then it should go to the root view for that tab.\r\n   *\r\n   *   a. Get the saved root view from the router outlet. If the saved root view\r\n   *      matches the tabRootUrl, set the route view to this view including the\r\n   *      navigation extras.\r\n   *   b. If the saved root view from the router outlet does\r\n   *      not match, navigate to the tabRootUrl. No navigation extras are\r\n   *      included.\r\n   *\r\n   * 2. If the current tab tab is not currently selected, get the last route\r\n   *    view from the router outlet.\r\n   *\r\n   *   a. If the last route view exists, navigate to that view including any\r\n   *      navigation extras\r\n   *   b. If the last route view doesn't exist, then navigate\r\n   *      to the default tabRootUrl\r\n   */\n  select(tabOrEvent) {\n    const isTabString = typeof tabOrEvent === 'string';\n    const tab = isTabString ? tabOrEvent : tabOrEvent.detail.tab;\n    const alreadySelected = this.outlet.getActiveStackId() === tab;\n    const tabRootUrl = `${this.outlet.tabsPrefix}/${tab}`;\n    /**\r\n     * If this is a nested tab, prevent the event\r\n     * from bubbling otherwise the outer tabs\r\n     * will respond to this event too, causing\r\n     * the app to get directed to the wrong place.\r\n     */\n    if (!isTabString) {\n      tabOrEvent.stopPropagation();\n    }\n    if (alreadySelected) {\n      const activeStackId = this.outlet.getActiveStackId();\n      const activeView = this.outlet.getLastRouteView(activeStackId);\n      // If on root tab, do not navigate to root tab again\n      if (activeView?.url === tabRootUrl) {\n        return;\n      }\n      const rootView = this.outlet.getRootView(tab);\n      const navigationExtras = rootView && tabRootUrl === rootView.url && rootView.savedExtras;\n      return this.navCtrl.navigateRoot(tabRootUrl, {\n        ...navigationExtras,\n        animated: true,\n        animationDirection: 'back'\n      });\n    } else {\n      const lastRoute = this.outlet.getLastRouteView(tab);\n      /**\r\n       * If there is a lastRoute, goto that, otherwise goto the fallback url of the\r\n       * selected tab\r\n       */\n      const url = lastRoute?.url || tabRootUrl;\n      const navigationExtras = lastRoute?.savedExtras;\n      return this.navCtrl.navigateRoot(url, {\n        ...navigationExtras,\n        animated: true,\n        animationDirection: 'back'\n      });\n    }\n  }\n  getSelected() {\n    return this.outlet.getActiveStackId();\n  }\n  /**\r\n   * Detects changes to the slot attribute of the tab bar.\r\n   *\r\n   * If the slot attribute has changed, then the tab bar\r\n   * should be relocated to the new slot position.\r\n   */\n  detectSlotChanges() {\n    this.tabBars.forEach(tabBar => {\n      // el is a protected attribute from the generated component wrapper\n      const currentSlot = tabBar.el.getAttribute('slot');\n      if (currentSlot !== this.tabBarSlot) {\n        this.tabBarSlot = currentSlot;\n        this.relocateTabBar();\n      }\n    });\n  }\n  /**\r\n   * Relocates the tab bar to the new slot position.\r\n   */\n  relocateTabBar() {\n    /**\r\n     * `el` is a protected attribute from the generated component wrapper.\r\n     * To avoid having to manually create the wrapper for tab bar, we\r\n     * cast the tab bar to any and access the protected attribute.\r\n     */\n    const tabBar = this.tabBar.el;\n    if (this.tabBarSlot === 'top') {\n      /**\r\n       * A tab bar with a slot of \"top\" should be inserted\r\n       * at the top of the container.\r\n       */\n      this.tabsInner.nativeElement.before(tabBar);\n    } else {\n      /**\r\n       * A tab bar with a slot of \"bottom\" or without a slot\r\n       * should be inserted at the end of the container.\r\n       */\n      this.tabsInner.nativeElement.after(tabBar);\n    }\n  }\n  /** @nocollapse */\n  static ɵfac = function IonTabs_Factory(t) {\n    return new (t || IonTabs)(i0.ɵɵdirectiveInject(NavController));\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IonTabs,\n    selectors: [[\"ion-tabs\"]],\n    viewQuery: function IonTabs_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabsInner = _t.first);\n      }\n    },\n    hostBindings: function IonTabs_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionTabButtonClick\", function IonTabs_ionTabButtonClick_HostBindingHandler($event) {\n          return ctx.select($event);\n        });\n      }\n    },\n    outputs: {\n      ionTabsWillChange: \"ionTabsWillChange\",\n      ionTabsDidChange: \"ionTabsDidChange\"\n    }\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IonTabs, [{\n    type: Directive,\n    args: [{\n      selector: 'ion-tabs'\n    }]\n  }], function () {\n    return [{\n      type: NavController\n    }];\n  }, {\n    tabsInner: [{\n      type: ViewChild,\n      args: ['tabsInner', {\n        read: ElementRef,\n        static: true\n      }]\n    }],\n    ionTabsWillChange: [{\n      type: Output\n    }],\n    ionTabsDidChange: [{\n      type: Output\n    }],\n    select: [{\n      type: HostListener,\n      args: ['ionTabButtonClick', ['$event']]\n    }]\n  });\n})();\nconst raf = h => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\n\n// TODO(FW-2827): types\nclass ValueAccessor {\n  injector;\n  elementRef;\n  onChange = () => {\n    /**/\n  };\n  onTouched = () => {\n    /**/\n  };\n  lastValue;\n  statusChanges;\n  constructor(injector, elementRef) {\n    this.injector = injector;\n    this.elementRef = elementRef;\n  }\n  writeValue(value) {\n    this.elementRef.nativeElement.value = this.lastValue = value;\n    setIonicClasses(this.elementRef);\n  }\n  /**\r\n   * Notifies the ControlValueAccessor of a change in the value of the control.\r\n   *\r\n   * This is called by each of the ValueAccessor directives when we want to update\r\n   * the status and validity of the form control. For example with text components this\r\n   * is called when the ionInput event is fired. For select components this is called\r\n   * when the ionChange event is fired.\r\n   *\r\n   * This also updates the Ionic form status classes on the element.\r\n   *\r\n   * @param el The component element.\r\n   * @param value The new value of the control.\r\n   */\n  handleValueChange(el, value) {\n    if (el === this.elementRef.nativeElement) {\n      if (value !== this.lastValue) {\n        this.lastValue = value;\n        this.onChange(value);\n      }\n      setIonicClasses(this.elementRef);\n    }\n  }\n  _handleBlurEvent(el) {\n    if (el === this.elementRef.nativeElement) {\n      this.onTouched();\n      setIonicClasses(this.elementRef);\n    }\n  }\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n  setDisabledState(isDisabled) {\n    this.elementRef.nativeElement.disabled = isDisabled;\n  }\n  ngOnDestroy() {\n    if (this.statusChanges) {\n      this.statusChanges.unsubscribe();\n    }\n  }\n  ngAfterViewInit() {\n    let ngControl;\n    try {\n      ngControl = this.injector.get(NgControl);\n    } catch {\n      /* No FormControl or ngModel binding */\n    }\n    if (!ngControl) {\n      return;\n    }\n    // Listen for changes in validity, disabled, or pending states\n    if (ngControl.statusChanges) {\n      this.statusChanges = ngControl.statusChanges.subscribe(() => setIonicClasses(this.elementRef));\n    }\n    /**\r\n     * TODO FW-2787: Remove this in favor of https://github.com/angular/angular/issues/10887\r\n     * whenever it is implemented.\r\n     */\n    const formControl = ngControl.control;\n    if (formControl) {\n      const methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];\n      methodsToPatch.forEach(method => {\n        if (typeof formControl[method] !== 'undefined') {\n          const oldFn = formControl[method].bind(formControl);\n          formControl[method] = (...params) => {\n            oldFn(...params);\n            setIonicClasses(this.elementRef);\n          };\n        }\n      });\n    }\n  }\n  /** @nocollapse */\n  static ɵfac = function ValueAccessor_Factory(t) {\n    return new (t || ValueAccessor)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  /** @nocollapse */\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ValueAccessor,\n    hostBindings: function ValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"ionBlur\", function ValueAccessor_ionBlur_HostBindingHandler($event) {\n          return ctx._handleBlurEvent($event.target);\n        });\n      }\n    }\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ValueAccessor, [{\n    type: Directive\n  }], function () {\n    return [{\n      type: i0.Injector\n    }, {\n      type: i0.ElementRef\n    }];\n  }, {\n    _handleBlurEvent: [{\n      type: HostListener,\n      args: ['ionBlur', ['$event.target']]\n    }]\n  });\n})();\nconst setIonicClasses = element => {\n  raf(() => {\n    const input = element.nativeElement;\n    const hasValue = input.value != null && input.value.toString().length > 0;\n    const classes = getClasses(input);\n    setClasses(input, classes);\n    const item = input.closest('ion-item');\n    if (item) {\n      if (hasValue) {\n        setClasses(item, [...classes, 'item-has-value']);\n      } else {\n        setClasses(item, classes);\n      }\n    }\n  });\n};\nconst getClasses = element => {\n  const classList = element.classList;\n  const classes = [];\n  for (let i = 0; i < classList.length; i++) {\n    const item = classList.item(i);\n    if (item !== null && startsWith(item, 'ng-')) {\n      classes.push(`ion-${item.substring(3)}`);\n    }\n  }\n  return classes;\n};\nconst setClasses = (element, classes) => {\n  const classList = element.classList;\n  classList.remove('ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine');\n  classList.add(...classes);\n};\nconst startsWith = (input, search) => {\n  return input.substring(0, search.length) === search;\n};\n\n/**\r\n * Provides a way to customize when activated routes get reused.\r\n */\nclass IonicRouteStrategy {\n  /**\r\n   * Whether the given route should detach for later reuse.\r\n   */\n  shouldDetach(_route) {\n    return false;\n  }\n  /**\r\n   * Returns `false`, meaning the route (and its subtree) is never reattached\r\n   */\n  shouldAttach(_route) {\n    return false;\n  }\n  /**\r\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\r\n   */\n  store(_route, _detachedTree) {\n    return;\n  }\n  /**\r\n   * Returns `null` because this strategy does not store routes for later re-use.\r\n   */\n  retrieve(_route) {\n    return null;\n  }\n  /**\r\n   * Determines if a route should be reused.\r\n   * This strategy returns `true` when the future route config and\r\n   * current route config are identical and all route parameters are identical.\r\n   */\n  shouldReuseRoute(future, curr) {\n    if (future.routeConfig !== curr.routeConfig) {\n      return false;\n    }\n    // checking router params\n    const futureParams = future.params;\n    const currentParams = curr.params;\n    const keysA = Object.keys(futureParams);\n    const keysB = Object.keys(currentParams);\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n    // Test for A's keys different from B.\n    for (const key of keysA) {\n      if (currentParams[key] !== futureParams[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n// TODO(FW-2827): types\nclass OverlayBaseController {\n  ctrl;\n  constructor(ctrl) {\n    this.ctrl = ctrl;\n  }\n  /**\r\n   * Creates a new overlay\r\n   */\n  create(opts) {\n    return this.ctrl.create(opts || {});\n  }\n  /**\r\n   * When `id` is not provided, it dismisses the top overlay.\r\n   */\n  dismiss(data, role, id) {\n    return this.ctrl.dismiss(data, role, id);\n  }\n  /**\r\n   * Returns the top overlay.\r\n   */\n  getTop() {\n    return this.ctrl.getTop();\n  }\n}\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AngularDelegate, Config, ConfigToken, DomController, IonBackButton, IonModal, IonNav, IonPopover, IonRouterOutlet, IonTabs, IonicRouteStrategy, MenuController, NavController, NavParams, OverlayBaseController, Platform, ProxyCmp, RouterLinkDelegateDirective, RouterLinkWithHrefDelegateDirective, ValueAccessor, bindLifecycleEvents, provideComponentInputBinding, raf, setIonicClasses };","map":{"version":3,"names":["i0","Injectable","Inject","Optional","InjectionToken","inject","NgZone","ApplicationRef","Injector","createComponent","TemplateRef","Directive","ContentChild","EventEmitter","ViewContainerRef","EnvironmentInjector","Attribute","SkipSelf","Input","Output","reflectComponentType","HostListener","ElementRef","ViewChild","i3","NavigationStart","PRIMARY_OUTLET","ChildrenOutletContexts","ActivatedRoute","Router","i1","DOCUMENT","isPlatform","getPlatforms","LIFECYCLE_WILL_ENTER","LIFECYCLE_DID_ENTER","LIFECYCLE_WILL_LEAVE","LIFECYCLE_DID_LEAVE","LIFECYCLE_WILL_UNLOAD","componentOnReady","Subject","fromEvent","BehaviorSubject","combineLatest","of","__decorate","filter","switchMap","distinctUntilChanged","NgControl","_c0","MenuController","menuController","constructor","open","menuId","close","toggle","enable","shouldEnable","swipeGesture","isOpen","isEnabled","get","getOpen","getMenus","registerAnimation","name","animation","isAnimating","_getOpenSync","_createAnimation","type","menuCmp","_register","menu","_unregister","_setOpen","shouldOpen","animated","DomController","read","cb","getQueue","write","ɵfac","DomController_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","args","win","window","Ionic","queue","requestAnimationFrame","Platform","doc","_readyPromise","backButton","keyboardDidShow","keyboardDidHide","pause","resume","resize","zone","run","defaultView","subscribeWithPriority","priority","callback","subscribe","ev","register","processNextHandler","proxyEvent","readyResolve","Promise","res","addEventListener","once","is","platformName","platforms","ready","isRTL","dir","getQueryParam","key","readQueryParam","location","href","isLandscape","isPortrait","matchMedia","matches","testUserAgent","expression","nav","navigator","userAgent","indexOf","url","width","innerWidth","height","innerHeight","Platform_Factory","ɵɵinject","undefined","decorators","replace","regex","RegExp","results","exec","decodeURIComponent","emitter","el","eventName","value","detail","next","NavController","serializer","router","topOutlet","direction","DEFAULT_DIRECTION","DEFAULT_ANIMATED","animationBuilder","guessDirection","guessAnimation","lastNavId","platform","events","id","restoredState","navigationId","pop","navigateForward","options","setDirection","animationDirection","navigate","navigateBack","navigateRoot","back","_this","_asyncToGenerator","outlet","parentOutlet","getAnimation","setTopOutlet","consumeTransition","Array","isArray","urlTree","parse","toString","queryParams","fragment","navigateByUrl","NavController_Factory","Location","UrlSerializer","Config","fallback","c","getConfig","getBoolean","getNumber","Config_Factory","ConfigToken","config","NavParams","data","param","AngularDelegate","applicationRef","create","environmentInjector","injector","elementReferenceKey","AngularFrameworkDelegate","AngularDelegate_Factory","elRefMap","WeakMap","elEventsMap","attachViewToDom","container","component","params","cssClasses","resolve","componentProps","attachView","removeViewFromDom","_container","componentRef","destroy","delete","unbindEvents","childInjector","providers","getProviders","parent","elementInjector","instance","hostElement","nativeElement","console","error","tagName","toLowerCase","Object","assign","cssClass","classList","add","bindLifecycleEvents","appendChild","hostView","set","LIFECYCLES","element","unregisters","map","handler","removeEventListener","forEach","fn","NavParamsToken","provide","useValue","useFactory","provideNavParamsInjectable","deps","proxyInputs","Cmp","inputs","Prototype","prototype","item","defineProperty","val","z","runOutsideAngular","proxyMethods","methods","methodName","arguments","apply","proxyOutputs","ProxyCmp","opts","decorator","cls","defineCustomElementFn","POPOVER_INPUTS","POPOVER_METHODS","IonPopover","template","isCmpOpen","r","detectChanges","IonPopover_Factory","ɵɵdirectiveInject","ChangeDetectorRef","ɵdir","ɵɵdefineDirective","selectors","contentQueries","IonPopover_ContentQueries","rf","ctx","dirIndex","ɵɵcontentQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","first","alignment","arrow","keepContentsMounted","backdropDismiss","dismissOnSelect","enterAnimation","event","keyboardClose","leaveAnimation","mode","showBackdrop","translucent","trigger","triggerAction","reference","size","side","selector","static","MODAL_INPUTS","MODAL_METHODS","IonModal","IonModal_Factory","IonModal_ContentQueries","backdropBreakpoint","breakpoints","canDismiss","handle","handleBehavior","initialBreakpoint","presentingElement","insertView","views","view","setRoot","setForward","setBack","v","stackId","push","index","getUrl","activatedRoute","createUrlTree","relativeTo","serializeUrl","isTabSwitch","enteringView","leavingView","computeStackId","prefixUrl","segments","toSegments","i","length","path","split","s","trim","destroyView","ref","unlistenEvents","StackController","containerEl","navCtrl","runningTask","skipTransition","tabsPrefix","activeView","nextId","createView","getExistingView","activatedUrlKey","find","vw","changeDetectorRef","reattach","setActive","consumeResult","tabSwitch","viewsSnapshot","slice","currentNavigation","getCurrentNavigation","navigations","extras","replaceUrl","splice","reused","includes","customAnimation","wait","detach","transition","canGoBack","then","cleanupAsync","deep","getActiveStackId","getStack","viewSavedData","savedData","primaryOutlet","route","_routerState","snapshot","savedExtras","startBackTransition","endBackTransition","shouldComplete","cleanup","getLastUrl","getRootUrl","getActiveView","hasRunningTask","showGoBack","progressAnimation","enteringEl","leavingEl","commit","duration","task","_this2","promise","finally","activeRoute","locationWithoutParams","locationWithoutFragment","setAttribute","IonRouterOutlet","nativeEl","activatedView","_swipeGesture","stackCtrl","proxyMap","currentActivatedRoute$","activated","activatedComponentRef","_activatedRoute","stackWillChange","stackDidChange","activateEvents","deactivateEvents","parentContexts","inputBinder","INPUT_BINDER","optional","supportsBindingToComponentInputs","swipe","swipeHandler","canStart","onStart","onEnd","shouldContinue","tabs","commonLocation","elementRef","onChildOutletCreated","ngOnDestroy","unsubscribeFromRouteData","getContext","ngOnInit","initializeOutletWithName","context","activateWith","isActivated","Error","activatedRouteData","attach","_ref","deactivate","Map","children","contextSnapshot","emit","cmpRef","saved","updateActivatedRouteProxy","_futureSnapshot","childContexts","getOrCreateContext","component$","activatedRouteProxy","createActivatedRouteProxy","OutletInjector","routeConfig","outletContent","bindActivatedRouteToOutletComponent","active","getLastRouteView","getRootView","proxy","_paramMap","proxyObservable","_queryParamMap","pipe","current","IonRouterOutlet_Factory","ɵɵinjectAttribute","outputs","exportAs","notFoundValue","RoutedComponentInputBinder","outletDataSubscriptions","subscribeToRouteData","unsubscribe","dataSubscription","mirror","templateName","setInput","RoutedComponentInputBinder_Factory","provideComponentInputBinding","componentInputBindingFactory","componentInputBindingEnabled","BACK_BUTTON_INPUTS","IonBackButton","routerOutlet","onClick","defaultHref","routerAnimation","preventDefault","IonBackButton_Factory","hostBindings","IonBackButton_HostBindings","ɵɵlistener","IonBackButton_click_HostBindingHandler","$event","color","disabled","icon","text","RouterLinkDelegateDirective","locationStrategy","routerLink","routerDirection","updateTargetUrlAndHref","ngOnChanges","prepareExternalUrl","RouterLinkDelegateDirective_Factory","LocationStrategy","RouterLink","RouterLinkDelegateDirective_HostBindings","RouterLinkDelegateDirective_click_HostBindingHandler","features","ɵɵNgOnChangesFeature","RouterLinkWithHrefDelegateDirective","RouterLinkWithHrefDelegateDirective_Factory","RouterLinkWithHrefDelegateDirective_HostBindings","RouterLinkWithHrefDelegateDirective_click_HostBindingHandler","NAV_INPUTS","NAV_METHODS","IonNav","angularDelegate","delegate","IonNav_Factory","root","rootParams","IonTabs","tabsInner","ionTabsWillChange","ionTabsDidChange","tabBarSlot","ngAfterContentInit","detectSlotChanges","ngAfterContentChecked","onStackWillChange","tab","onStackDidChange","tabBar","selectedTab","select","tabOrEvent","isTabString","alreadySelected","tabRootUrl","stopPropagation","activeStackId","rootView","navigationExtras","lastRoute","getSelected","tabBars","currentSlot","getAttribute","relocateTabBar","before","after","IonTabs_Factory","viewQuery","IonTabs_Query","ɵɵviewQuery","IonTabs_HostBindings","IonTabs_ionTabButtonClick_HostBindingHandler","raf","h","__zone_symbol__requestAnimationFrame","setTimeout","ValueAccessor","onChange","onTouched","lastValue","statusChanges","writeValue","setIonicClasses","handleValueChange","_handleBlurEvent","registerOnChange","registerOnTouched","setDisabledState","isDisabled","ngAfterViewInit","ngControl","formControl","control","methodsToPatch","method","oldFn","bind","ValueAccessor_Factory","ValueAccessor_HostBindings","ValueAccessor_ionBlur_HostBindingHandler","target","input","hasValue","classes","getClasses","setClasses","closest","startsWith","substring","remove","search","IonicRouteStrategy","shouldDetach","_route","shouldAttach","store","_detachedTree","retrieve","shouldReuseRoute","future","curr","futureParams","currentParams","keysA","keys","keysB","OverlayBaseController","ctrl","dismiss","role","getTop"],"sources":["C:/Users/Aluno/Desktop/Nova pasta/integrador_2024/node_modules/@ionic/angular/fesm2022/ionic-angular-common.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\r\nimport { Injectable, Inject, Optional, InjectionToken, inject, NgZone, ApplicationRef, Injector, createComponent, TemplateRef, Directive, ContentChild, EventEmitter, ViewContainerRef, EnvironmentInjector, Attribute, SkipSelf, Input, Output, reflectComponentType, HostListener, ElementRef, ViewChild } from '@angular/core';\r\nimport * as i3 from '@angular/router';\r\nimport { NavigationStart, PRIMARY_OUTLET, ChildrenOutletContexts, ActivatedRoute, Router } from '@angular/router';\r\nimport * as i1 from '@angular/common';\r\nimport { DOCUMENT } from '@angular/common';\r\nimport { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, componentOnReady } from '@ionic/core/components';\r\nimport { Subject, fromEvent, BehaviorSubject, combineLatest, of } from 'rxjs';\r\nimport { __decorate } from 'tslib';\r\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\r\nimport { NgControl } from '@angular/forms';\r\n\r\nclass MenuController {\r\n    menuController;\r\n    constructor(menuController) {\r\n        this.menuController = menuController;\r\n    }\r\n    /**\r\n     * Programmatically open the Menu.\r\n     * @param [menuId]  Optionally get the menu by its id, or side.\r\n     * @return returns a promise when the menu is fully opened\r\n     */\r\n    open(menuId) {\r\n        return this.menuController.open(menuId);\r\n    }\r\n    /**\r\n     * Programmatically close the Menu. If no `menuId` is given as the first\r\n     * argument then it'll close any menu which is open. If a `menuId`\r\n     * is given then it'll close that exact menu.\r\n     * @param [menuId]  Optionally get the menu by its id, or side.\r\n     * @return returns a promise when the menu is fully closed\r\n     */\r\n    close(menuId) {\r\n        return this.menuController.close(menuId);\r\n    }\r\n    /**\r\n     * Toggle the menu. If it's closed, it will open, and if opened, it\r\n     * will close.\r\n     * @param [menuId]  Optionally get the menu by its id, or side.\r\n     * @return returns a promise when the menu has been toggled\r\n     */\r\n    toggle(menuId) {\r\n        return this.menuController.toggle(menuId);\r\n    }\r\n    /**\r\n     * Used to enable or disable a menu. For example, there could be multiple\r\n     * left menus, but only one of them should be able to be opened at the same\r\n     * time. If there are multiple menus on the same side, then enabling one menu\r\n     * will also automatically disable all the others that are on the same side.\r\n     * @param [menuId]  Optionally get the menu by its id, or side.\r\n     * @return Returns the instance of the menu, which is useful for chaining.\r\n     */\r\n    enable(shouldEnable, menuId) {\r\n        return this.menuController.enable(shouldEnable, menuId);\r\n    }\r\n    /**\r\n     * Used to enable or disable the ability to swipe open the menu.\r\n     * @param shouldEnable  True if it should be swipe-able, false if not.\r\n     * @param [menuId]  Optionally get the menu by its id, or side.\r\n     * @return Returns the instance of the menu, which is useful for chaining.\r\n     */\r\n    swipeGesture(shouldEnable, menuId) {\r\n        return this.menuController.swipeGesture(shouldEnable, menuId);\r\n    }\r\n    /**\r\n     * @param [menuId] Optionally get the menu by its id, or side.\r\n     * @return Returns true if the specified menu is currently open, otherwise false.\r\n     * If the menuId is not specified, it returns true if ANY menu is currenly open.\r\n     */\r\n    isOpen(menuId) {\r\n        return this.menuController.isOpen(menuId);\r\n    }\r\n    /**\r\n     * @param [menuId]  Optionally get the menu by its id, or side.\r\n     * @return Returns true if the menu is currently enabled, otherwise false.\r\n     */\r\n    isEnabled(menuId) {\r\n        return this.menuController.isEnabled(menuId);\r\n    }\r\n    /**\r\n     * Used to get a menu instance. If a `menuId` is not provided then it'll\r\n     * return the first menu found. If a `menuId` is `left` or `right`, then\r\n     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\r\n     * provided, then it'll try to find the menu using the menu's `id`\r\n     * property. If a menu is not found then it'll return `null`.\r\n     * @param [menuId]  Optionally get the menu by its id, or side.\r\n     * @return Returns the instance of the menu if found, otherwise `null`.\r\n     */\r\n    get(menuId) {\r\n        return this.menuController.get(menuId);\r\n    }\r\n    /**\r\n     * @return Returns the instance of the menu already opened, otherwise `null`.\r\n     */\r\n    getOpen() {\r\n        return this.menuController.getOpen();\r\n    }\r\n    /**\r\n     * @return Returns an array of all menu instances.\r\n     */\r\n    getMenus() {\r\n        return this.menuController.getMenus();\r\n    }\r\n    registerAnimation(name, animation) {\r\n        return this.menuController.registerAnimation(name, animation);\r\n    }\r\n    isAnimating() {\r\n        return this.menuController.isAnimating();\r\n    }\r\n    _getOpenSync() {\r\n        return this.menuController._getOpenSync();\r\n    }\r\n    _createAnimation(type, menuCmp) {\r\n        return this.menuController._createAnimation(type, menuCmp);\r\n    }\r\n    _register(menu) {\r\n        return this.menuController._register(menu);\r\n    }\r\n    _unregister(menu) {\r\n        return this.menuController._unregister(menu);\r\n    }\r\n    _setOpen(menu, shouldOpen, animated) {\r\n        return this.menuController._setOpen(menu, shouldOpen, animated);\r\n    }\r\n}\r\n\r\nclass DomController {\r\n    /**\r\n     * Schedules a task to run during the READ phase of the next frame.\r\n     * This task should only read the DOM, but never modify it.\r\n     */\r\n    read(cb) {\r\n        getQueue().read(cb);\r\n    }\r\n    /**\r\n     * Schedules a task to run during the WRITE phase of the next frame.\r\n     * This task should write the DOM, but never READ it.\r\n     */\r\n    write(cb) {\r\n        getQueue().write(cb);\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: DomController, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: DomController, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: DomController, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root',\r\n                }]\r\n        }] });\r\nconst getQueue = () => {\r\n    const win = typeof window !== 'undefined' ? window : null;\r\n    if (win != null) {\r\n        const Ionic = win.Ionic;\r\n        if (Ionic?.queue) {\r\n            return Ionic.queue;\r\n        }\r\n        return {\r\n            read: (cb) => win.requestAnimationFrame(cb),\r\n            write: (cb) => win.requestAnimationFrame(cb),\r\n        };\r\n    }\r\n    return {\r\n        read: (cb) => cb(),\r\n        write: (cb) => cb(),\r\n    };\r\n};\r\n\r\nclass Platform {\r\n    doc;\r\n    _readyPromise;\r\n    win;\r\n    /**\r\n     * @hidden\r\n     */\r\n    backButton = new Subject();\r\n    /**\r\n     * The keyboardDidShow event emits when the\r\n     * on-screen keyboard is presented.\r\n     */\r\n    keyboardDidShow = new Subject();\r\n    /**\r\n     * The keyboardDidHide event emits when the\r\n     * on-screen keyboard is hidden.\r\n     */\r\n    keyboardDidHide = new Subject();\r\n    /**\r\n     * The pause event emits when the native platform puts the application\r\n     * into the background, typically when the user switches to a different\r\n     * application. This event would emit when a Cordova app is put into\r\n     * the background, however, it would not fire on a standard web browser.\r\n     */\r\n    pause = new Subject();\r\n    /**\r\n     * The resume event emits when the native platform pulls the application\r\n     * out from the background. This event would emit when a Cordova app comes\r\n     * out from the background, however, it would not fire on a standard web browser.\r\n     */\r\n    resume = new Subject();\r\n    /**\r\n     * The resize event emits when the browser window has changed dimensions. This\r\n     * could be from a browser window being physically resized, or from a device\r\n     * changing orientation.\r\n     */\r\n    resize = new Subject();\r\n    constructor(doc, zone) {\r\n        this.doc = doc;\r\n        zone.run(() => {\r\n            this.win = doc.defaultView;\r\n            this.backButton.subscribeWithPriority = function (priority, callback) {\r\n                return this.subscribe((ev) => {\r\n                    return ev.register(priority, (processNextHandler) => zone.run(() => callback(processNextHandler)));\r\n                });\r\n            };\r\n            proxyEvent(this.pause, doc, 'pause', zone);\r\n            proxyEvent(this.resume, doc, 'resume', zone);\r\n            proxyEvent(this.backButton, doc, 'ionBackButton', zone);\r\n            proxyEvent(this.resize, this.win, 'resize', zone);\r\n            proxyEvent(this.keyboardDidShow, this.win, 'ionKeyboardDidShow', zone);\r\n            proxyEvent(this.keyboardDidHide, this.win, 'ionKeyboardDidHide', zone);\r\n            let readyResolve;\r\n            this._readyPromise = new Promise((res) => {\r\n                readyResolve = res;\r\n            });\r\n            if (this.win?.['cordova']) {\r\n                doc.addEventListener('deviceready', () => {\r\n                    readyResolve('cordova');\r\n                }, { once: true });\r\n            }\r\n            else {\r\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n                readyResolve('dom');\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @returns returns true/false based on platform.\r\n     * @description\r\n     * Depending on the platform the user is on, `is(platformName)` will\r\n     * return `true` or `false`. Note that the same app can return `true`\r\n     * for more than one platform name. For example, an app running from\r\n     * an iPad would return `true` for the platform names: `mobile`,\r\n     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\r\n     * from Cordova then `cordova` would be true, and if it was running\r\n     * from a web browser on the iPad then `mobileweb` would be `true`.\r\n     *\r\n     * ```\r\n     * import { Platform } from 'ionic-angular';\r\n     *\r\n     * @Component({...})\r\n     * export MyPage {\r\n     *   constructor(public platform: Platform) {\r\n     *     if (this.platform.is('ios')) {\r\n     *       // This will only print when on iOS\r\n     *       console.log('I am an iOS device!');\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * | Platform Name   | Description                        |\r\n     * |-----------------|------------------------------------|\r\n     * | android         | on a device running Android.       |\r\n     * | capacitor       | on a device running Capacitor.     |\r\n     * | cordova         | on a device running Cordova.       |\r\n     * | ios             | on a device running iOS.           |\r\n     * | ipad            | on an iPad device.                 |\r\n     * | iphone          | on an iPhone device.               |\r\n     * | phablet         | on a phablet device.               |\r\n     * | tablet          | on a tablet device.                |\r\n     * | electron        | in Electron on a desktop device.   |\r\n     * | pwa             | as a PWA app.                      |\r\n     * | mobile          | on a mobile device.                |\r\n     * | mobileweb       | on a mobile device in a browser.   |\r\n     * | desktop         | on a desktop device.               |\r\n     * | hybrid          | is a cordova or capacitor app.     |\r\n     *\r\n     */\r\n    is(platformName) {\r\n        return isPlatform(this.win, platformName);\r\n    }\r\n    /**\r\n     * @returns the array of platforms\r\n     * @description\r\n     * Depending on what device you are on, `platforms` can return multiple values.\r\n     * Each possible value is a hierarchy of platforms. For example, on an iPhone,\r\n     * it would return `mobile`, `ios`, and `iphone`.\r\n     *\r\n     * ```\r\n     * import { Platform } from 'ionic-angular';\r\n     *\r\n     * @Component({...})\r\n     * export MyPage {\r\n     *   constructor(public platform: Platform) {\r\n     *     // This will print an array of the current platforms\r\n     *     console.log(this.platform.platforms());\r\n     *   }\r\n     * }\r\n     * ```\r\n     */\r\n    platforms() {\r\n        return getPlatforms(this.win);\r\n    }\r\n    /**\r\n     * Returns a promise when the platform is ready and native functionality\r\n     * can be called. If the app is running from within a web browser, then\r\n     * the promise will resolve when the DOM is ready. When the app is running\r\n     * from an application engine such as Cordova, then the promise will\r\n     * resolve when Cordova triggers the `deviceready` event.\r\n     *\r\n     * The resolved value is the `readySource`, which states which platform\r\n     * ready was used. For example, when Cordova is ready, the resolved ready\r\n     * source is `cordova`. The default ready source value will be `dom`. The\r\n     * `readySource` is useful if different logic should run depending on the\r\n     * platform the app is running from. For example, only Cordova can execute\r\n     * the status bar plugin, so the web should not run status bar plugin logic.\r\n     *\r\n     * ```\r\n     * import { Component } from '@angular/core';\r\n     * import { Platform } from 'ionic-angular';\r\n     *\r\n     * @Component({...})\r\n     * export MyApp {\r\n     *   constructor(public platform: Platform) {\r\n     *     this.platform.ready().then((readySource) => {\r\n     *       console.log('Platform ready from', readySource);\r\n     *       // Platform now ready, execute any required native code\r\n     *     });\r\n     *   }\r\n     * }\r\n     * ```\r\n     */\r\n    ready() {\r\n        return this._readyPromise;\r\n    }\r\n    /**\r\n     * Returns if this app is using right-to-left language direction or not.\r\n     * We recommend the app's `index.html` file already has the correct `dir`\r\n     * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\r\n     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\r\n     */\r\n    get isRTL() {\r\n        return this.doc.dir === 'rtl';\r\n    }\r\n    /**\r\n     * Get the query string parameter\r\n     */\r\n    getQueryParam(key) {\r\n        return readQueryParam(this.win.location.href, key);\r\n    }\r\n    /**\r\n     * Returns `true` if the app is in landscape mode.\r\n     */\r\n    isLandscape() {\r\n        return !this.isPortrait();\r\n    }\r\n    /**\r\n     * Returns `true` if the app is in portrait mode.\r\n     */\r\n    isPortrait() {\r\n        return this.win.matchMedia?.('(orientation: portrait)').matches;\r\n    }\r\n    testUserAgent(expression) {\r\n        const nav = this.win.navigator;\r\n        return !!(nav?.userAgent && nav.userAgent.indexOf(expression) >= 0);\r\n    }\r\n    /**\r\n     * Get the current url.\r\n     */\r\n    url() {\r\n        return this.win.location.href;\r\n    }\r\n    /**\r\n     * Gets the width of the platform's viewport using `window.innerWidth`.\r\n     */\r\n    width() {\r\n        return this.win.innerWidth;\r\n    }\r\n    /**\r\n     * Gets the height of the platform's viewport using `window.innerHeight`.\r\n     */\r\n    height() {\r\n        return this.win.innerHeight;\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Platform, deps: [{ token: DOCUMENT }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Platform, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Platform, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root',\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: i0.NgZone }]; } });\r\nconst readQueryParam = (url, key) => {\r\n    key = key.replace(/[[\\]\\\\]/g, '\\\\$&');\r\n    const regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\r\n    const results = regex.exec(url);\r\n    return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\r\n};\r\nconst proxyEvent = (emitter, el, eventName, zone) => {\r\n    if (el) {\r\n        el.addEventListener(eventName, (ev) => {\r\n            /**\r\n             * `zone.run` is required to make sure that we are running inside the Angular zone\r\n             * at all times. This is necessary since an app that has Capacitor will\r\n             * override the `document.addEventListener` with its own implementation.\r\n             * The override causes the event to no longer be in the Angular zone.\r\n             */\r\n            zone.run(() => {\r\n                // ?? cordova might emit \"null\" events\r\n                const value = ev != null ? ev.detail : undefined;\r\n                emitter.next(value);\r\n            });\r\n        });\r\n    }\r\n};\r\n\r\nclass NavController {\r\n    location;\r\n    serializer;\r\n    router;\r\n    topOutlet;\r\n    direction = DEFAULT_DIRECTION;\r\n    animated = DEFAULT_ANIMATED;\r\n    animationBuilder;\r\n    guessDirection = 'forward';\r\n    guessAnimation;\r\n    lastNavId = -1;\r\n    constructor(platform, location, serializer, router) {\r\n        this.location = location;\r\n        this.serializer = serializer;\r\n        this.router = router;\r\n        // Subscribe to router events to detect direction\r\n        if (router) {\r\n            router.events.subscribe((ev) => {\r\n                if (ev instanceof NavigationStart) {\r\n                    // restoredState is set if the browser back/forward button is used\r\n                    const id = ev.restoredState ? ev.restoredState.navigationId : ev.id;\r\n                    this.guessDirection = this.guessAnimation = id < this.lastNavId ? 'back' : 'forward';\r\n                    this.lastNavId = this.guessDirection === 'forward' ? ev.id : id;\r\n                }\r\n            });\r\n        }\r\n        // Subscribe to backButton events\r\n        platform.backButton.subscribeWithPriority(0, (processNextHandler) => {\r\n            this.pop();\r\n            processNextHandler();\r\n        });\r\n    }\r\n    /**\r\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\r\n     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\r\n     *\r\n     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\r\n     * and that it will show a \"forward\" animation by default.\r\n     *\r\n     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\r\n     *\r\n     * ```html\r\n     * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\r\n     * ```\r\n     */\r\n    navigateForward(url, options = {}) {\r\n        this.setDirection('forward', options.animated, options.animationDirection, options.animation);\r\n        return this.navigate(url, options);\r\n    }\r\n    /**\r\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\r\n     * it's equivalent to calling:\r\n     *\r\n     * ```ts\r\n     * this.navController.setDirection('back');\r\n     * this.router.navigateByUrl(path);\r\n     * ```\r\n     *\r\n     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\r\n     * and that it will show a \"back\" animation by default.\r\n     *\r\n     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\r\n     *\r\n     * ```html\r\n     * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\r\n     * ```\r\n     */\r\n    navigateBack(url, options = {}) {\r\n        this.setDirection('back', options.animated, options.animationDirection, options.animation);\r\n        return this.navigate(url, options);\r\n    }\r\n    /**\r\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\r\n     * it's equivalent to calling:\r\n     *\r\n     * ```ts\r\n     * this.navController.setDirection('root');\r\n     * this.router.navigateByUrl(path);\r\n     * ```\r\n     *\r\n     * Going **root** means that all existing pages in the stack will be removed,\r\n     * and the navigated page will become the single page in the stack.\r\n     *\r\n     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\r\n     *\r\n     * ```html\r\n     * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\r\n     * ```\r\n     */\r\n    navigateRoot(url, options = {}) {\r\n        this.setDirection('root', options.animated, options.animationDirection, options.animation);\r\n        return this.navigate(url, options);\r\n    }\r\n    /**\r\n     * Same as [Location](https://angular.io/api/common/Location)'s back() method.\r\n     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\r\n     * by default.\r\n     */\r\n    back(options = { animated: true, animationDirection: 'back' }) {\r\n        this.setDirection('back', options.animated, options.animationDirection, options.animation);\r\n        return this.location.back();\r\n    }\r\n    /**\r\n     * This methods goes back in the context of Ionic's stack navigation.\r\n     *\r\n     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\r\n     * This is the recommended way to go back when you are using `ion-router-outlet`.\r\n     *\r\n     * Resolves to `true` if it was able to pop.\r\n     */\r\n    async pop() {\r\n        let outlet = this.topOutlet;\r\n        while (outlet) {\r\n            if (await outlet.pop()) {\r\n                return true;\r\n            }\r\n            else {\r\n                outlet = outlet.parentOutlet;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * This methods specifies the direction of the next navigation performed by the Angular router.\r\n     *\r\n     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\r\n     *\r\n     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\r\n     */\r\n    setDirection(direction, animated, animationDirection, animationBuilder) {\r\n        this.direction = direction;\r\n        this.animated = getAnimation(direction, animated, animationDirection);\r\n        this.animationBuilder = animationBuilder;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    setTopOutlet(outlet) {\r\n        this.topOutlet = outlet;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    consumeTransition() {\r\n        let direction = 'root';\r\n        let animation;\r\n        const animationBuilder = this.animationBuilder;\r\n        if (this.direction === 'auto') {\r\n            direction = this.guessDirection;\r\n            animation = this.guessAnimation;\r\n        }\r\n        else {\r\n            animation = this.animated;\r\n            direction = this.direction;\r\n        }\r\n        this.direction = DEFAULT_DIRECTION;\r\n        this.animated = DEFAULT_ANIMATED;\r\n        this.animationBuilder = undefined;\r\n        return {\r\n            direction,\r\n            animation,\r\n            animationBuilder,\r\n        };\r\n    }\r\n    navigate(url, options) {\r\n        if (Array.isArray(url)) {\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            return this.router.navigate(url, options);\r\n        }\r\n        else {\r\n            /**\r\n             * navigateByUrl ignores any properties that\r\n             * would change the url, so things like queryParams\r\n             * would be ignored unless we create a url tree\r\n             * More Info: https://github.com/angular/angular/issues/18798\r\n             */\r\n            const urlTree = this.serializer.parse(url.toString());\r\n            if (options.queryParams !== undefined) {\r\n                urlTree.queryParams = { ...options.queryParams };\r\n            }\r\n            if (options.fragment !== undefined) {\r\n                urlTree.fragment = options.fragment;\r\n            }\r\n            /**\r\n             * `navigateByUrl` will still apply `NavigationExtras` properties\r\n             * that do not modify the url, such as `replaceUrl` which is why\r\n             * `options` is passed in here.\r\n             */\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            return this.router.navigateByUrl(urlTree, options);\r\n        }\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: NavController, deps: [{ token: Platform }, { token: i1.Location }, { token: i3.UrlSerializer }, { token: i3.Router, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: NavController, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: NavController, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root',\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: Platform }, { type: i1.Location }, { type: i3.UrlSerializer }, { type: i3.Router, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\r\nconst getAnimation = (direction, animated, animationDirection) => {\r\n    if (animated === false) {\r\n        return undefined;\r\n    }\r\n    if (animationDirection !== undefined) {\r\n        return animationDirection;\r\n    }\r\n    if (direction === 'forward' || direction === 'back') {\r\n        return direction;\r\n    }\r\n    else if (direction === 'root' && animated === true) {\r\n        return 'forward';\r\n    }\r\n    return undefined;\r\n};\r\nconst DEFAULT_DIRECTION = 'auto';\r\nconst DEFAULT_ANIMATED = undefined;\r\n\r\nclass Config {\r\n    get(key, fallback) {\r\n        const c = getConfig();\r\n        if (c) {\r\n            return c.get(key, fallback);\r\n        }\r\n        return null;\r\n    }\r\n    getBoolean(key, fallback) {\r\n        const c = getConfig();\r\n        if (c) {\r\n            return c.getBoolean(key, fallback);\r\n        }\r\n        return false;\r\n    }\r\n    getNumber(key, fallback) {\r\n        const c = getConfig();\r\n        if (c) {\r\n            return c.getNumber(key, fallback);\r\n        }\r\n        return 0;\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Config, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Config, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: Config, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root',\r\n                }]\r\n        }] });\r\nconst ConfigToken = new InjectionToken('USERCONFIG');\r\nconst getConfig = () => {\r\n    if (typeof window !== 'undefined') {\r\n        const Ionic = window.Ionic;\r\n        if (Ionic?.config) {\r\n            return Ionic.config;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n/**\r\n * @description\r\n * NavParams are an object that exists on a page and can contain data for that particular view.\r\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\r\n * option with a simple `get` method.\r\n *\r\n * @usage\r\n * ```ts\r\n * import { NavParams } from '@ionic/angular';\r\n *\r\n * export class MyClass{\r\n *\r\n *  constructor(navParams: NavParams){\r\n *    // userParams is an object we have in our nav-parameters\r\n *    navParams.get('userParams');\r\n *  }\r\n *\r\n * }\r\n * ```\r\n */\r\nclass NavParams {\r\n    data;\r\n    constructor(data = {}) {\r\n        this.data = data;\r\n    }\r\n    /**\r\n     * Get the value of a nav-parameter for the current view\r\n     *\r\n     * ```ts\r\n     * import { NavParams } from 'ionic-angular';\r\n     *\r\n     * export class MyClass{\r\n     *  constructor(public navParams: NavParams){\r\n     *    // userParams is an object we have in our nav-parameters\r\n     *    this.navParams.get('userParams');\r\n     *  }\r\n     * }\r\n     * ```\r\n     *\r\n     * @param param Which param you want to look up\r\n     */\r\n    get(param) {\r\n        return this.data[param];\r\n    }\r\n}\r\n\r\n// TODO(FW-2827): types\r\nclass AngularDelegate {\r\n    zone = inject(NgZone);\r\n    applicationRef = inject(ApplicationRef);\r\n    create(environmentInjector, injector, elementReferenceKey) {\r\n        return new AngularFrameworkDelegate(environmentInjector, injector, this.applicationRef, this.zone, elementReferenceKey);\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: AngularDelegate, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: AngularDelegate });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: AngularDelegate, decorators: [{\r\n            type: Injectable\r\n        }] });\r\nclass AngularFrameworkDelegate {\r\n    environmentInjector;\r\n    injector;\r\n    applicationRef;\r\n    zone;\r\n    elementReferenceKey;\r\n    elRefMap = new WeakMap();\r\n    elEventsMap = new WeakMap();\r\n    constructor(environmentInjector, injector, applicationRef, zone, elementReferenceKey) {\r\n        this.environmentInjector = environmentInjector;\r\n        this.injector = injector;\r\n        this.applicationRef = applicationRef;\r\n        this.zone = zone;\r\n        this.elementReferenceKey = elementReferenceKey;\r\n    }\r\n    attachViewToDom(container, component, params, cssClasses) {\r\n        return this.zone.run(() => {\r\n            return new Promise((resolve) => {\r\n                const componentProps = {\r\n                    ...params,\r\n                };\r\n                /**\r\n                 * Ionic Angular passes a reference to a modal\r\n                 * or popover that can be accessed using a\r\n                 * variable in the overlay component. If\r\n                 * elementReferenceKey is defined, then we should\r\n                 * pass a reference to the component using\r\n                 * elementReferenceKey as the key.\r\n                 */\r\n                if (this.elementReferenceKey !== undefined) {\r\n                    componentProps[this.elementReferenceKey] = container;\r\n                }\r\n                const el = attachView(this.zone, this.environmentInjector, this.injector, this.applicationRef, this.elRefMap, this.elEventsMap, container, component, componentProps, cssClasses, this.elementReferenceKey);\r\n                resolve(el);\r\n            });\r\n        });\r\n    }\r\n    removeViewFromDom(_container, component) {\r\n        return this.zone.run(() => {\r\n            return new Promise((resolve) => {\r\n                const componentRef = this.elRefMap.get(component);\r\n                if (componentRef) {\r\n                    componentRef.destroy();\r\n                    this.elRefMap.delete(component);\r\n                    const unbindEvents = this.elEventsMap.get(component);\r\n                    if (unbindEvents) {\r\n                        unbindEvents();\r\n                        this.elEventsMap.delete(component);\r\n                    }\r\n                }\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n}\r\nconst attachView = (zone, environmentInjector, injector, applicationRef, elRefMap, elEventsMap, container, component, params, cssClasses, elementReferenceKey) => {\r\n    /**\r\n     * Wraps the injector with a custom injector that\r\n     * provides NavParams to the component.\r\n     *\r\n     * NavParams is a legacy feature from Ionic v3 that allows\r\n     * Angular developers to provide data to a component\r\n     * and access it by providing NavParams as a dependency\r\n     * in the constructor.\r\n     *\r\n     * The modern approach is to access the data directly\r\n     * from the component's class instance.\r\n     */\r\n    const childInjector = Injector.create({\r\n        providers: getProviders(params),\r\n        parent: injector,\r\n    });\r\n    const componentRef = createComponent(component, {\r\n        environmentInjector,\r\n        elementInjector: childInjector,\r\n    });\r\n    const instance = componentRef.instance;\r\n    const hostElement = componentRef.location.nativeElement;\r\n    if (params) {\r\n        /**\r\n         * For modals and popovers, a reference to the component is\r\n         * added to `params` during the call to attachViewToDom. If\r\n         * a reference using this name is already set, this means\r\n         * the app is trying to use the name as a component prop,\r\n         * which will cause collisions.\r\n         */\r\n        if (elementReferenceKey && instance[elementReferenceKey] !== undefined) {\r\n            console.error(`[Ionic Error]: ${elementReferenceKey} is a reserved property when using ${container.tagName.toLowerCase()}. Rename or remove the \"${elementReferenceKey}\" property from ${component.name}.`);\r\n        }\r\n        Object.assign(instance, params);\r\n    }\r\n    if (cssClasses) {\r\n        for (const cssClass of cssClasses) {\r\n            hostElement.classList.add(cssClass);\r\n        }\r\n    }\r\n    const unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\r\n    container.appendChild(hostElement);\r\n    applicationRef.attachView(componentRef.hostView);\r\n    elRefMap.set(hostElement, componentRef);\r\n    elEventsMap.set(hostElement, unbindEvents);\r\n    return hostElement;\r\n};\r\nconst LIFECYCLES = [\r\n    LIFECYCLE_WILL_ENTER,\r\n    LIFECYCLE_DID_ENTER,\r\n    LIFECYCLE_WILL_LEAVE,\r\n    LIFECYCLE_DID_LEAVE,\r\n    LIFECYCLE_WILL_UNLOAD,\r\n];\r\nconst bindLifecycleEvents = (zone, instance, element) => {\r\n    return zone.run(() => {\r\n        const unregisters = LIFECYCLES.filter((eventName) => typeof instance[eventName] === 'function').map((eventName) => {\r\n            const handler = (ev) => instance[eventName](ev.detail);\r\n            element.addEventListener(eventName, handler);\r\n            return () => element.removeEventListener(eventName, handler);\r\n        });\r\n        return () => unregisters.forEach((fn) => fn());\r\n    });\r\n};\r\nconst NavParamsToken = new InjectionToken('NavParamsToken');\r\nconst getProviders = (params) => {\r\n    return [\r\n        {\r\n            provide: NavParamsToken,\r\n            useValue: params,\r\n        },\r\n        {\r\n            provide: NavParams,\r\n            useFactory: provideNavParamsInjectable,\r\n            deps: [NavParamsToken],\r\n        },\r\n    ];\r\n};\r\nconst provideNavParamsInjectable = (params) => {\r\n    return new NavParams(params);\r\n};\r\n\r\n// TODO: Is there a way we can grab this from angular-component-lib instead?\r\n/* eslint-disable */\r\n/* tslint:disable */\r\nconst proxyInputs = (Cmp, inputs) => {\r\n    const Prototype = Cmp.prototype;\r\n    inputs.forEach((item) => {\r\n        Object.defineProperty(Prototype, item, {\r\n            get() {\r\n                return this.el[item];\r\n            },\r\n            set(val) {\r\n                this.z.runOutsideAngular(() => (this.el[item] = val));\r\n            },\r\n        });\r\n    });\r\n};\r\nconst proxyMethods = (Cmp, methods) => {\r\n    const Prototype = Cmp.prototype;\r\n    methods.forEach((methodName) => {\r\n        Prototype[methodName] = function () {\r\n            const args = arguments;\r\n            return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));\r\n        };\r\n    });\r\n};\r\nconst proxyOutputs = (instance, el, events) => {\r\n    events.forEach((eventName) => (instance[eventName] = fromEvent(el, eventName)));\r\n};\r\n// tslint:disable-next-line: only-arrow-functions\r\nfunction ProxyCmp(opts) {\r\n    const decorator = function (cls) {\r\n        const { defineCustomElementFn, inputs, methods } = opts;\r\n        if (defineCustomElementFn !== undefined) {\r\n            defineCustomElementFn();\r\n        }\r\n        if (inputs) {\r\n            proxyInputs(cls, inputs);\r\n        }\r\n        if (methods) {\r\n            proxyMethods(cls, methods);\r\n        }\r\n        return cls;\r\n    };\r\n    return decorator;\r\n}\r\n\r\nconst POPOVER_INPUTS = [\r\n    'alignment',\r\n    'animated',\r\n    'arrow',\r\n    'keepContentsMounted',\r\n    'backdropDismiss',\r\n    'cssClass',\r\n    'dismissOnSelect',\r\n    'enterAnimation',\r\n    'event',\r\n    'isOpen',\r\n    'keyboardClose',\r\n    'leaveAnimation',\r\n    'mode',\r\n    'showBackdrop',\r\n    'translucent',\r\n    'trigger',\r\n    'triggerAction',\r\n    'reference',\r\n    'size',\r\n    'side',\r\n];\r\nconst POPOVER_METHODS = ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss'];\r\nlet IonPopover = class IonPopover {\r\n    z;\r\n    // TODO(FW-2827): type\r\n    template;\r\n    isCmpOpen = false;\r\n    el;\r\n    constructor(c, r, z) {\r\n        this.z = z;\r\n        this.el = r.nativeElement;\r\n        this.el.addEventListener('ionMount', () => {\r\n            this.isCmpOpen = true;\r\n            c.detectChanges();\r\n        });\r\n        this.el.addEventListener('didDismiss', () => {\r\n            this.isCmpOpen = false;\r\n            c.detectChanges();\r\n        });\r\n        proxyOutputs(this, this.el, [\r\n            'ionPopoverDidPresent',\r\n            'ionPopoverWillPresent',\r\n            'ionPopoverWillDismiss',\r\n            'ionPopoverDidDismiss',\r\n            'didPresent',\r\n            'willPresent',\r\n            'willDismiss',\r\n            'didDismiss',\r\n        ]);\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonPopover, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\r\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonPopover, selector: \"ion-popover\", inputs: { alignment: \"alignment\", animated: \"animated\", arrow: \"arrow\", keepContentsMounted: \"keepContentsMounted\", backdropDismiss: \"backdropDismiss\", cssClass: \"cssClass\", dismissOnSelect: \"dismissOnSelect\", enterAnimation: \"enterAnimation\", event: \"event\", isOpen: \"isOpen\", keyboardClose: \"keyboardClose\", leaveAnimation: \"leaveAnimation\", mode: \"mode\", showBackdrop: \"showBackdrop\", translucent: \"translucent\", trigger: \"trigger\", triggerAction: \"triggerAction\", reference: \"reference\", size: \"size\", side: \"side\" }, queries: [{ propertyName: \"template\", first: true, predicate: TemplateRef, descendants: true }], ngImport: i0 });\r\n};\r\nIonPopover = __decorate([\r\n    ProxyCmp({\r\n        inputs: POPOVER_INPUTS,\r\n        methods: POPOVER_METHODS,\r\n    })\r\n    /**\r\n     * @Component extends from @Directive\r\n     * so by defining the inputs here we\r\n     * do not need to re-define them for the\r\n     * lazy loaded popover.\r\n     */\r\n], IonPopover);\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonPopover, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: 'ion-popover',\r\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\r\n                    inputs: POPOVER_INPUTS,\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { template: [{\r\n                type: ContentChild,\r\n                args: [TemplateRef, { static: false }]\r\n            }] } });\r\n\r\nconst MODAL_INPUTS = [\r\n    'animated',\r\n    'keepContentsMounted',\r\n    'backdropBreakpoint',\r\n    'backdropDismiss',\r\n    'breakpoints',\r\n    'canDismiss',\r\n    'cssClass',\r\n    'enterAnimation',\r\n    'event',\r\n    'handle',\r\n    'handleBehavior',\r\n    'initialBreakpoint',\r\n    'isOpen',\r\n    'keyboardClose',\r\n    'leaveAnimation',\r\n    'mode',\r\n    'presentingElement',\r\n    'showBackdrop',\r\n    'translucent',\r\n    'trigger',\r\n];\r\nconst MODAL_METHODS = [\r\n    'present',\r\n    'dismiss',\r\n    'onDidDismiss',\r\n    'onWillDismiss',\r\n    'setCurrentBreakpoint',\r\n    'getCurrentBreakpoint',\r\n];\r\nlet IonModal = class IonModal {\r\n    z;\r\n    // TODO(FW-2827): type\r\n    template;\r\n    isCmpOpen = false;\r\n    el;\r\n    constructor(c, r, z) {\r\n        this.z = z;\r\n        this.el = r.nativeElement;\r\n        this.el.addEventListener('ionMount', () => {\r\n            this.isCmpOpen = true;\r\n            c.detectChanges();\r\n        });\r\n        this.el.addEventListener('didDismiss', () => {\r\n            this.isCmpOpen = false;\r\n            c.detectChanges();\r\n        });\r\n        proxyOutputs(this, this.el, [\r\n            'ionModalDidPresent',\r\n            'ionModalWillPresent',\r\n            'ionModalWillDismiss',\r\n            'ionModalDidDismiss',\r\n            'ionBreakpointDidChange',\r\n            'didPresent',\r\n            'willPresent',\r\n            'willDismiss',\r\n            'didDismiss',\r\n        ]);\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonModal, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\r\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonModal, selector: \"ion-modal\", inputs: { animated: \"animated\", keepContentsMounted: \"keepContentsMounted\", backdropBreakpoint: \"backdropBreakpoint\", backdropDismiss: \"backdropDismiss\", breakpoints: \"breakpoints\", canDismiss: \"canDismiss\", cssClass: \"cssClass\", enterAnimation: \"enterAnimation\", event: \"event\", handle: \"handle\", handleBehavior: \"handleBehavior\", initialBreakpoint: \"initialBreakpoint\", isOpen: \"isOpen\", keyboardClose: \"keyboardClose\", leaveAnimation: \"leaveAnimation\", mode: \"mode\", presentingElement: \"presentingElement\", showBackdrop: \"showBackdrop\", translucent: \"translucent\", trigger: \"trigger\" }, queries: [{ propertyName: \"template\", first: true, predicate: TemplateRef, descendants: true }], ngImport: i0 });\r\n};\r\nIonModal = __decorate([\r\n    ProxyCmp({\r\n        inputs: MODAL_INPUTS,\r\n        methods: MODAL_METHODS,\r\n    })\r\n    /**\r\n     * @Component extends from @Directive\r\n     * so by defining the inputs here we\r\n     * do not need to re-define them for the\r\n     * lazy loaded popover.\r\n     */\r\n], IonModal);\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonModal, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: 'ion-modal',\r\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\r\n                    inputs: MODAL_INPUTS,\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { template: [{\r\n                type: ContentChild,\r\n                args: [TemplateRef, { static: false }]\r\n            }] } });\r\n\r\nconst insertView = (views, view, direction) => {\r\n    if (direction === 'root') {\r\n        return setRoot(views, view);\r\n    }\r\n    else if (direction === 'forward') {\r\n        return setForward(views, view);\r\n    }\r\n    else {\r\n        return setBack(views, view);\r\n    }\r\n};\r\nconst setRoot = (views, view) => {\r\n    views = views.filter((v) => v.stackId !== view.stackId);\r\n    views.push(view);\r\n    return views;\r\n};\r\nconst setForward = (views, view) => {\r\n    const index = views.indexOf(view);\r\n    if (index >= 0) {\r\n        views = views.filter((v) => v.stackId !== view.stackId || v.id <= view.id);\r\n    }\r\n    else {\r\n        views.push(view);\r\n    }\r\n    return views;\r\n};\r\nconst setBack = (views, view) => {\r\n    const index = views.indexOf(view);\r\n    if (index >= 0) {\r\n        return views.filter((v) => v.stackId !== view.stackId || v.id <= view.id);\r\n    }\r\n    else {\r\n        return setRoot(views, view);\r\n    }\r\n};\r\nconst getUrl = (router, activatedRoute) => {\r\n    const urlTree = router.createUrlTree(['.'], { relativeTo: activatedRoute });\r\n    return router.serializeUrl(urlTree);\r\n};\r\nconst isTabSwitch = (enteringView, leavingView) => {\r\n    if (!leavingView) {\r\n        return true;\r\n    }\r\n    return enteringView.stackId !== leavingView.stackId;\r\n};\r\nconst computeStackId = (prefixUrl, url) => {\r\n    if (!prefixUrl) {\r\n        return undefined;\r\n    }\r\n    const segments = toSegments(url);\r\n    for (let i = 0; i < segments.length; i++) {\r\n        if (i >= prefixUrl.length) {\r\n            return segments[i];\r\n        }\r\n        if (segments[i] !== prefixUrl[i]) {\r\n            return undefined;\r\n        }\r\n    }\r\n    return undefined;\r\n};\r\nconst toSegments = (path) => {\r\n    return path\r\n        .split('/')\r\n        .map((s) => s.trim())\r\n        .filter((s) => s !== '');\r\n};\r\nconst destroyView = (view) => {\r\n    if (view) {\r\n        view.ref.destroy();\r\n        view.unlistenEvents();\r\n    }\r\n};\r\n\r\n// TODO(FW-2827): types\r\nclass StackController {\r\n    containerEl;\r\n    router;\r\n    navCtrl;\r\n    zone;\r\n    location;\r\n    views = [];\r\n    runningTask;\r\n    skipTransition = false;\r\n    tabsPrefix;\r\n    activeView;\r\n    nextId = 0;\r\n    constructor(tabsPrefix, containerEl, router, navCtrl, zone, location) {\r\n        this.containerEl = containerEl;\r\n        this.router = router;\r\n        this.navCtrl = navCtrl;\r\n        this.zone = zone;\r\n        this.location = location;\r\n        this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\r\n    }\r\n    createView(ref, activatedRoute) {\r\n        const url = getUrl(this.router, activatedRoute);\r\n        const element = ref?.location?.nativeElement;\r\n        const unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\r\n        return {\r\n            id: this.nextId++,\r\n            stackId: computeStackId(this.tabsPrefix, url),\r\n            unlistenEvents,\r\n            element,\r\n            ref,\r\n            url,\r\n        };\r\n    }\r\n    getExistingView(activatedRoute) {\r\n        const activatedUrlKey = getUrl(this.router, activatedRoute);\r\n        const view = this.views.find((vw) => vw.url === activatedUrlKey);\r\n        if (view) {\r\n            view.ref.changeDetectorRef.reattach();\r\n        }\r\n        return view;\r\n    }\r\n    setActive(enteringView) {\r\n        const consumeResult = this.navCtrl.consumeTransition();\r\n        let { direction, animation, animationBuilder } = consumeResult;\r\n        const leavingView = this.activeView;\r\n        const tabSwitch = isTabSwitch(enteringView, leavingView);\r\n        if (tabSwitch) {\r\n            direction = 'back';\r\n            animation = undefined;\r\n        }\r\n        const viewsSnapshot = this.views.slice();\r\n        let currentNavigation;\r\n        const router = this.router;\r\n        // Angular >= 7.2.0\r\n        if (router.getCurrentNavigation) {\r\n            currentNavigation = router.getCurrentNavigation();\r\n            // Angular < 7.2.0\r\n        }\r\n        else if (router.navigations?.value) {\r\n            currentNavigation = router.navigations.value;\r\n        }\r\n        /**\r\n         * If the navigation action\r\n         * sets `replaceUrl: true`\r\n         * then we need to make sure\r\n         * we remove the last item\r\n         * from our views stack\r\n         */\r\n        if (currentNavigation?.extras?.replaceUrl) {\r\n            if (this.views.length > 0) {\r\n                this.views.splice(-1, 1);\r\n            }\r\n        }\r\n        const reused = this.views.includes(enteringView);\r\n        const views = this.insertView(enteringView, direction);\r\n        // Trigger change detection before transition starts\r\n        // This will call ngOnInit() the first time too, just after the view\r\n        // was attached to the dom, but BEFORE the transition starts\r\n        if (!reused) {\r\n            enteringView.ref.changeDetectorRef.detectChanges();\r\n        }\r\n        /**\r\n         * If we are going back from a page that\r\n         * was presented using a custom animation\r\n         * we should default to using that\r\n         * unless the developer explicitly\r\n         * provided another animation.\r\n         */\r\n        const customAnimation = enteringView.animationBuilder;\r\n        if (animationBuilder === undefined && direction === 'back' && !tabSwitch && customAnimation !== undefined) {\r\n            animationBuilder = customAnimation;\r\n        }\r\n        /**\r\n         * Save any custom animation so that navigating\r\n         * back will use this custom animation by default.\r\n         */\r\n        if (leavingView) {\r\n            leavingView.animationBuilder = animationBuilder;\r\n        }\r\n        // Wait until previous transitions finish\r\n        return this.zone.runOutsideAngular(() => {\r\n            return this.wait(() => {\r\n                // disconnect leaving page from change detection to\r\n                // reduce jank during the page transition\r\n                if (leavingView) {\r\n                    leavingView.ref.changeDetectorRef.detach();\r\n                }\r\n                // In case the enteringView is the same as the leavingPage we need to reattach()\r\n                enteringView.ref.changeDetectorRef.reattach();\r\n                return this.transition(enteringView, leavingView, animation, this.canGoBack(1), false, animationBuilder)\r\n                    .then(() => cleanupAsync(enteringView, views, viewsSnapshot, this.location, this.zone))\r\n                    .then(() => ({\r\n                    enteringView,\r\n                    direction,\r\n                    animation,\r\n                    tabSwitch,\r\n                }));\r\n            });\r\n        });\r\n    }\r\n    canGoBack(deep, stackId = this.getActiveStackId()) {\r\n        return this.getStack(stackId).length > deep;\r\n    }\r\n    pop(deep, stackId = this.getActiveStackId()) {\r\n        return this.zone.run(() => {\r\n            const views = this.getStack(stackId);\r\n            if (views.length <= deep) {\r\n                return Promise.resolve(false);\r\n            }\r\n            const view = views[views.length - deep - 1];\r\n            let url = view.url;\r\n            const viewSavedData = view.savedData;\r\n            if (viewSavedData) {\r\n                const primaryOutlet = viewSavedData.get('primary');\r\n                if (primaryOutlet?.route?._routerState?.snapshot.url) {\r\n                    url = primaryOutlet.route._routerState.snapshot.url;\r\n                }\r\n            }\r\n            const { animationBuilder } = this.navCtrl.consumeTransition();\r\n            return this.navCtrl.navigateBack(url, { ...view.savedExtras, animation: animationBuilder }).then(() => true);\r\n        });\r\n    }\r\n    startBackTransition() {\r\n        const leavingView = this.activeView;\r\n        if (leavingView) {\r\n            const views = this.getStack(leavingView.stackId);\r\n            const enteringView = views[views.length - 2];\r\n            const customAnimation = enteringView.animationBuilder;\r\n            return this.wait(() => {\r\n                return this.transition(enteringView, // entering view\r\n                leavingView, // leaving view\r\n                'back', this.canGoBack(2), true, customAnimation);\r\n            });\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    endBackTransition(shouldComplete) {\r\n        if (shouldComplete) {\r\n            this.skipTransition = true;\r\n            this.pop(1);\r\n        }\r\n        else if (this.activeView) {\r\n            cleanup(this.activeView, this.views, this.views, this.location, this.zone);\r\n        }\r\n    }\r\n    getLastUrl(stackId) {\r\n        const views = this.getStack(stackId);\r\n        return views.length > 0 ? views[views.length - 1] : undefined;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    getRootUrl(stackId) {\r\n        const views = this.getStack(stackId);\r\n        return views.length > 0 ? views[0] : undefined;\r\n    }\r\n    getActiveStackId() {\r\n        return this.activeView ? this.activeView.stackId : undefined;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    getActiveView() {\r\n        return this.activeView;\r\n    }\r\n    hasRunningTask() {\r\n        return this.runningTask !== undefined;\r\n    }\r\n    destroy() {\r\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n        this.containerEl = undefined;\r\n        this.views.forEach(destroyView);\r\n        this.activeView = undefined;\r\n        this.views = [];\r\n    }\r\n    getStack(stackId) {\r\n        return this.views.filter((v) => v.stackId === stackId);\r\n    }\r\n    insertView(enteringView, direction) {\r\n        this.activeView = enteringView;\r\n        this.views = insertView(this.views, enteringView, direction);\r\n        return this.views.slice();\r\n    }\r\n    transition(enteringView, leavingView, direction, showGoBack, progressAnimation, animationBuilder) {\r\n        if (this.skipTransition) {\r\n            this.skipTransition = false;\r\n            return Promise.resolve(false);\r\n        }\r\n        if (leavingView === enteringView) {\r\n            return Promise.resolve(false);\r\n        }\r\n        const enteringEl = enteringView ? enteringView.element : undefined;\r\n        const leavingEl = leavingView ? leavingView.element : undefined;\r\n        const containerEl = this.containerEl;\r\n        if (enteringEl && enteringEl !== leavingEl) {\r\n            enteringEl.classList.add('ion-page');\r\n            enteringEl.classList.add('ion-page-invisible');\r\n            if (containerEl.commit) {\r\n                return containerEl.commit(enteringEl, leavingEl, {\r\n                    duration: direction === undefined ? 0 : undefined,\r\n                    direction,\r\n                    showGoBack,\r\n                    progressAnimation,\r\n                    animationBuilder,\r\n                });\r\n            }\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n    async wait(task) {\r\n        if (this.runningTask !== undefined) {\r\n            await this.runningTask;\r\n            this.runningTask = undefined;\r\n        }\r\n        const promise = (this.runningTask = task());\r\n        promise.finally(() => (this.runningTask = undefined));\r\n        return promise;\r\n    }\r\n}\r\nconst cleanupAsync = (activeRoute, views, viewsSnapshot, location, zone) => {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        return new Promise((resolve) => {\r\n            requestAnimationFrame(() => {\r\n                cleanup(activeRoute, views, viewsSnapshot, location, zone);\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n    return Promise.resolve();\r\n};\r\nconst cleanup = (activeRoute, views, viewsSnapshot, location, zone) => {\r\n    /**\r\n     * Re-enter the Angular zone when destroying page components. This will allow\r\n     * lifecycle events (`ngOnDestroy`) to be run inside the Angular zone.\r\n     */\r\n    zone.run(() => viewsSnapshot.filter((view) => !views.includes(view)).forEach(destroyView));\r\n    views.forEach((view) => {\r\n        /**\r\n         * In the event that a user navigated multiple\r\n         * times in rapid succession, we want to make sure\r\n         * we don't pre-emptively detach a view while\r\n         * it is in mid-transition.\r\n         *\r\n         * In this instance we also do not care about query\r\n         * params or fragments as it will be the same view regardless\r\n         */\r\n        const locationWithoutParams = location.path().split('?')[0];\r\n        const locationWithoutFragment = locationWithoutParams.split('#')[0];\r\n        if (view !== activeRoute && view.url !== locationWithoutFragment) {\r\n            const element = view.element;\r\n            element.setAttribute('aria-hidden', 'true');\r\n            element.classList.add('ion-page-hidden');\r\n            view.ref.changeDetectorRef.detach();\r\n        }\r\n    });\r\n};\r\n\r\n// TODO(FW-2827): types\r\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\r\nclass IonRouterOutlet {\r\n    parentOutlet;\r\n    nativeEl;\r\n    activatedView = null;\r\n    tabsPrefix;\r\n    _swipeGesture;\r\n    stackCtrl;\r\n    // Maintain map of activated route proxies for each component instance\r\n    proxyMap = new WeakMap();\r\n    // Keep the latest activated route in a subject for the proxy routes to switch map to\r\n    currentActivatedRoute$ = new BehaviorSubject(null);\r\n    activated = null;\r\n    /** @internal */\r\n    get activatedComponentRef() {\r\n        return this.activated;\r\n    }\r\n    _activatedRoute = null;\r\n    /**\r\n     * The name of the outlet\r\n     */\r\n    name = PRIMARY_OUTLET;\r\n    /** @internal */\r\n    stackWillChange = new EventEmitter();\r\n    /** @internal */\r\n    stackDidChange = new EventEmitter();\r\n    // eslint-disable-next-line @angular-eslint/no-output-rename\r\n    activateEvents = new EventEmitter();\r\n    // eslint-disable-next-line @angular-eslint/no-output-rename\r\n    deactivateEvents = new EventEmitter();\r\n    parentContexts = inject(ChildrenOutletContexts);\r\n    location = inject(ViewContainerRef);\r\n    environmentInjector = inject(EnvironmentInjector);\r\n    inputBinder = inject(INPUT_BINDER, { optional: true });\r\n    /** @nodoc */\r\n    supportsBindingToComponentInputs = true;\r\n    // Ionic providers\r\n    config = inject(Config);\r\n    navCtrl = inject(NavController);\r\n    set animation(animation) {\r\n        this.nativeEl.animation = animation;\r\n    }\r\n    set animated(animated) {\r\n        this.nativeEl.animated = animated;\r\n    }\r\n    set swipeGesture(swipe) {\r\n        this._swipeGesture = swipe;\r\n        this.nativeEl.swipeHandler = swipe\r\n            ? {\r\n                canStart: () => this.stackCtrl.canGoBack(1) && !this.stackCtrl.hasRunningTask(),\r\n                onStart: () => this.stackCtrl.startBackTransition(),\r\n                onEnd: (shouldContinue) => this.stackCtrl.endBackTransition(shouldContinue),\r\n            }\r\n            : undefined;\r\n    }\r\n    constructor(name, tabs, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\r\n        this.parentOutlet = parentOutlet;\r\n        this.nativeEl = elementRef.nativeElement;\r\n        this.name = name || PRIMARY_OUTLET;\r\n        this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\r\n        this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, this.navCtrl, zone, commonLocation);\r\n        this.parentContexts.onChildOutletCreated(this.name, this);\r\n    }\r\n    ngOnDestroy() {\r\n        this.stackCtrl.destroy();\r\n        this.inputBinder?.unsubscribeFromRouteData(this);\r\n    }\r\n    getContext() {\r\n        return this.parentContexts.getContext(this.name);\r\n    }\r\n    ngOnInit() {\r\n        this.initializeOutletWithName();\r\n    }\r\n    // Note: Ionic deviates from the Angular Router implementation here\r\n    initializeOutletWithName() {\r\n        if (!this.activated) {\r\n            // If the outlet was not instantiated at the time the route got activated we need to populate\r\n            // the outlet when it is initialized (ie inside a NgIf)\r\n            const context = this.getContext();\r\n            if (context?.route) {\r\n                this.activateWith(context.route, context.injector);\r\n            }\r\n        }\r\n        new Promise((resolve) => componentOnReady(this.nativeEl, resolve)).then(() => {\r\n            if (this._swipeGesture === undefined) {\r\n                this.swipeGesture = this.config.getBoolean('swipeBackEnabled', this.nativeEl.mode === 'ios');\r\n            }\r\n        });\r\n    }\r\n    get isActivated() {\r\n        return !!this.activated;\r\n    }\r\n    get component() {\r\n        if (!this.activated) {\r\n            throw new Error('Outlet is not activated');\r\n        }\r\n        return this.activated.instance;\r\n    }\r\n    get activatedRoute() {\r\n        if (!this.activated) {\r\n            throw new Error('Outlet is not activated');\r\n        }\r\n        return this._activatedRoute;\r\n    }\r\n    get activatedRouteData() {\r\n        if (this._activatedRoute) {\r\n            return this._activatedRoute.snapshot.data;\r\n        }\r\n        return {};\r\n    }\r\n    /**\r\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\r\n     */\r\n    detach() {\r\n        throw new Error('incompatible reuse strategy');\r\n    }\r\n    /**\r\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    attach(_ref, _activatedRoute) {\r\n        throw new Error('incompatible reuse strategy');\r\n    }\r\n    deactivate() {\r\n        if (this.activated) {\r\n            if (this.activatedView) {\r\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n                const context = this.getContext();\r\n                this.activatedView.savedData = new Map(context.children['contexts']);\r\n                /**\r\n                 * Angular v11.2.10 introduced a change\r\n                 * where this route context is cleared out when\r\n                 * a router-outlet is deactivated, However,\r\n                 * we need this route information in order to\r\n                 * return a user back to the correct tab when\r\n                 * leaving and then going back to the tab context.\r\n                 */\r\n                const primaryOutlet = this.activatedView.savedData.get('primary');\r\n                if (primaryOutlet && context.route) {\r\n                    primaryOutlet.route = { ...context.route };\r\n                }\r\n                /**\r\n                 * Ensure we are saving the NavigationExtras\r\n                 * data otherwise it will be lost\r\n                 */\r\n                this.activatedView.savedExtras = {};\r\n                if (context.route) {\r\n                    const contextSnapshot = context.route.snapshot;\r\n                    this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\r\n                    this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\r\n                }\r\n            }\r\n            const c = this.component;\r\n            this.activatedView = null;\r\n            this.activated = null;\r\n            this._activatedRoute = null;\r\n            this.deactivateEvents.emit(c);\r\n        }\r\n    }\r\n    activateWith(activatedRoute, environmentInjector) {\r\n        if (this.isActivated) {\r\n            throw new Error('Cannot activate an already activated outlet');\r\n        }\r\n        this._activatedRoute = activatedRoute;\r\n        let cmpRef;\r\n        let enteringView = this.stackCtrl.getExistingView(activatedRoute);\r\n        if (enteringView) {\r\n            cmpRef = this.activated = enteringView.ref;\r\n            const saved = enteringView.savedData;\r\n            if (saved) {\r\n                // self-restore\r\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n                const context = this.getContext();\r\n                context.children['contexts'] = saved;\r\n            }\r\n            // Updated activated route proxy for this component\r\n            this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\r\n        }\r\n        else {\r\n            const snapshot = activatedRoute._futureSnapshot;\r\n            /**\r\n             * Angular 14 introduces a new `loadComponent` property to the route config.\r\n             * This function will assign a `component` property to the route snapshot.\r\n             * We check for the presence of this property to determine if the route is\r\n             * using standalone components.\r\n             */\r\n            const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\r\n            // We create an activated route proxy object that will maintain future updates for this component\r\n            // over its lifecycle in the stack.\r\n            const component$ = new BehaviorSubject(null);\r\n            const activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\r\n            const injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            const component = snapshot.routeConfig.component ?? snapshot.component;\r\n            /**\r\n             * View components need to be added as a child of ion-router-outlet\r\n             * for page transitions and swipe to go back.\r\n             * However, createComponent mounts components as siblings of the\r\n             * ViewContainerRef. As a result, outletContent must reference\r\n             * an ng-container inside of ion-router-outlet and not\r\n             * ion-router-outlet itself.\r\n             */\r\n            cmpRef = this.activated = this.outletContent.createComponent(component, {\r\n                index: this.outletContent.length,\r\n                injector,\r\n                environmentInjector: environmentInjector ?? this.environmentInjector,\r\n            });\r\n            // Once the component is created we can push it to our local subject supplied to the proxy\r\n            component$.next(cmpRef.instance);\r\n            // Calling `markForCheck` to make sure we will run the change detection when the\r\n            // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\r\n            /**\r\n             * At this point this.activated has been set earlier\r\n             * in this function, so it is guaranteed to be non-null.\r\n             */\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            enteringView = this.stackCtrl.createView(this.activated, activatedRoute);\r\n            // Store references to the proxy by component\r\n            this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\r\n            this.currentActivatedRoute$.next({ component: cmpRef.instance, activatedRoute });\r\n        }\r\n        this.inputBinder?.bindActivatedRouteToOutletComponent(this);\r\n        this.activatedView = enteringView;\r\n        /**\r\n         * The top outlet is set prior to the entering view's transition completing,\r\n         * so that when we have nested outlets (e.g. ion-tabs inside an ion-router-outlet),\r\n         * the tabs outlet will be assigned as the top outlet when a view inside tabs is\r\n         * activated.\r\n         *\r\n         * In this scenario, activeWith is called for both the tabs and the root router outlet.\r\n         * To avoid a race condition, we assign the top outlet synchronously.\r\n         */\r\n        this.navCtrl.setTopOutlet(this);\r\n        const leavingView = this.stackCtrl.getActiveView();\r\n        this.stackWillChange.emit({\r\n            enteringView,\r\n            tabSwitch: isTabSwitch(enteringView, leavingView),\r\n        });\r\n        this.stackCtrl.setActive(enteringView).then((data) => {\r\n            this.activateEvents.emit(cmpRef.instance);\r\n            this.stackDidChange.emit(data);\r\n        });\r\n    }\r\n    /**\r\n     * Returns `true` if there are pages in the stack to go back.\r\n     */\r\n    canGoBack(deep = 1, stackId) {\r\n        return this.stackCtrl.canGoBack(deep, stackId);\r\n    }\r\n    /**\r\n     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\r\n     */\r\n    pop(deep = 1, stackId) {\r\n        return this.stackCtrl.pop(deep, stackId);\r\n    }\r\n    /**\r\n     * Returns the URL of the active page of each stack.\r\n     */\r\n    getLastUrl(stackId) {\r\n        const active = this.stackCtrl.getLastUrl(stackId);\r\n        return active ? active.url : undefined;\r\n    }\r\n    /**\r\n     * Returns the RouteView of the active page of each stack.\r\n     * @internal\r\n     */\r\n    getLastRouteView(stackId) {\r\n        return this.stackCtrl.getLastUrl(stackId);\r\n    }\r\n    /**\r\n     * Returns the root view in the tab stack.\r\n     * @internal\r\n     */\r\n    getRootView(stackId) {\r\n        return this.stackCtrl.getRootUrl(stackId);\r\n    }\r\n    /**\r\n     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\r\n     */\r\n    getActiveStackId() {\r\n        return this.stackCtrl.getActiveStackId();\r\n    }\r\n    /**\r\n     * Since the activated route can change over the life time of a component in an ion router outlet, we create\r\n     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\r\n     */\r\n    createActivatedRouteProxy(component$, activatedRoute) {\r\n        const proxy = new ActivatedRoute();\r\n        proxy._futureSnapshot = activatedRoute._futureSnapshot;\r\n        proxy._routerState = activatedRoute._routerState;\r\n        proxy.snapshot = activatedRoute.snapshot;\r\n        proxy.outlet = activatedRoute.outlet;\r\n        proxy.component = activatedRoute.component;\r\n        // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\r\n        proxy._paramMap = this.proxyObservable(component$, 'paramMap');\r\n        proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\r\n        proxy.url = this.proxyObservable(component$, 'url');\r\n        proxy.params = this.proxyObservable(component$, 'params');\r\n        proxy.queryParams = this.proxyObservable(component$, 'queryParams');\r\n        proxy.fragment = this.proxyObservable(component$, 'fragment');\r\n        proxy.data = this.proxyObservable(component$, 'data');\r\n        return proxy;\r\n    }\r\n    /**\r\n     * Create a wrapped observable that will switch to the latest activated route matched by the given component\r\n     */\r\n    proxyObservable(component$, path) {\r\n        return component$.pipe(\r\n        // First wait until the component instance is pushed\r\n        filter((component) => !!component), switchMap((component) => this.currentActivatedRoute$.pipe(filter((current) => current !== null && current.component === component), switchMap((current) => current && current.activatedRoute[path]), distinctUntilChanged())));\r\n    }\r\n    /**\r\n     * Updates the activated route proxy for the given component to the new incoming router state\r\n     */\r\n    updateActivatedRouteProxy(component, activatedRoute) {\r\n        const proxy = this.proxyMap.get(component);\r\n        if (!proxy) {\r\n            throw new Error(`Could not find activated route proxy for view`);\r\n        }\r\n        proxy._futureSnapshot = activatedRoute._futureSnapshot;\r\n        proxy._routerState = activatedRoute._routerState;\r\n        proxy.snapshot = activatedRoute.snapshot;\r\n        proxy.outlet = activatedRoute.outlet;\r\n        proxy.component = activatedRoute.component;\r\n        this.currentActivatedRoute$.next({ component, activatedRoute });\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonRouterOutlet, deps: [{ token: 'name', attribute: true }, { token: 'tabs', attribute: true, optional: true }, { token: i1.Location }, { token: i0.ElementRef }, { token: i3.Router }, { token: i0.NgZone }, { token: i3.ActivatedRoute }, { token: IonRouterOutlet, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });\r\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonRouterOutlet, selector: \"ion-router-outlet\", inputs: { animated: \"animated\", animation: \"animation\", mode: \"mode\", swipeGesture: \"swipeGesture\", name: \"name\" }, outputs: { stackWillChange: \"stackWillChange\", stackDidChange: \"stackDidChange\", activateEvents: \"activate\", deactivateEvents: \"deactivate\" }, exportAs: [\"outlet\"], ngImport: i0 });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonRouterOutlet, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: 'ion-router-outlet',\r\n                    exportAs: 'outlet',\r\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\r\n                    inputs: ['animated', 'animation', 'mode', 'swipeGesture'],\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Attribute,\r\n                    args: ['name']\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Optional\r\n                }, {\r\n                    type: Attribute,\r\n                    args: ['tabs']\r\n                }] }, { type: i1.Location }, { type: i0.ElementRef }, { type: i3.Router }, { type: i0.NgZone }, { type: i3.ActivatedRoute }, { type: IonRouterOutlet, decorators: [{\r\n                    type: SkipSelf\r\n                }, {\r\n                    type: Optional\r\n                }] }]; }, propDecorators: { name: [{\r\n                type: Input\r\n            }], stackWillChange: [{\r\n                type: Output\r\n            }], stackDidChange: [{\r\n                type: Output\r\n            }], activateEvents: [{\r\n                type: Output,\r\n                args: ['activate']\r\n            }], deactivateEvents: [{\r\n                type: Output,\r\n                args: ['deactivate']\r\n            }] } });\r\nclass OutletInjector {\r\n    route;\r\n    childContexts;\r\n    parent;\r\n    constructor(route, childContexts, parent) {\r\n        this.route = route;\r\n        this.childContexts = childContexts;\r\n        this.parent = parent;\r\n    }\r\n    get(token, notFoundValue) {\r\n        if (token === ActivatedRoute) {\r\n            return this.route;\r\n        }\r\n        if (token === ChildrenOutletContexts) {\r\n            return this.childContexts;\r\n        }\r\n        return this.parent.get(token, notFoundValue);\r\n    }\r\n}\r\n// TODO: FW-4785 - Remove this once Angular 15 support is dropped\r\nconst INPUT_BINDER = new InjectionToken('');\r\n/**\r\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\r\n * inputs.\r\n *\r\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\r\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\r\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\r\n * Importantly, when an input does not have an item in the route data with a matching key, this\r\n * input is set to `undefined`. If it were not done this way, the previous information would be\r\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\r\n *\r\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\r\n * the subscriptions are cleaned up.\r\n */\r\nclass RoutedComponentInputBinder {\r\n    outletDataSubscriptions = new Map();\r\n    bindActivatedRouteToOutletComponent(outlet) {\r\n        this.unsubscribeFromRouteData(outlet);\r\n        this.subscribeToRouteData(outlet);\r\n    }\r\n    unsubscribeFromRouteData(outlet) {\r\n        this.outletDataSubscriptions.get(outlet)?.unsubscribe();\r\n        this.outletDataSubscriptions.delete(outlet);\r\n    }\r\n    subscribeToRouteData(outlet) {\r\n        const { activatedRoute } = outlet;\r\n        const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data])\r\n            .pipe(switchMap(([queryParams, params, data], index) => {\r\n            data = { ...queryParams, ...params, ...data };\r\n            // Get the first result from the data subscription synchronously so it's available to\r\n            // the component as soon as possible (and doesn't require a second change detection).\r\n            if (index === 0) {\r\n                return of(data);\r\n            }\r\n            // Promise.resolve is used to avoid synchronously writing the wrong data when\r\n            // two of the Observables in the `combineLatest` stream emit one after\r\n            // another.\r\n            return Promise.resolve(data);\r\n        }))\r\n            .subscribe((data) => {\r\n            // Outlet may have been deactivated or changed names to be associated with a different\r\n            // route\r\n            if (!outlet.isActivated ||\r\n                !outlet.activatedComponentRef ||\r\n                outlet.activatedRoute !== activatedRoute ||\r\n                activatedRoute.component === null) {\r\n                this.unsubscribeFromRouteData(outlet);\r\n                return;\r\n            }\r\n            const mirror = reflectComponentType(activatedRoute.component);\r\n            if (!mirror) {\r\n                this.unsubscribeFromRouteData(outlet);\r\n                return;\r\n            }\r\n            for (const { templateName } of mirror.inputs) {\r\n                outlet.activatedComponentRef.setInput(templateName, data[templateName]);\r\n            }\r\n        });\r\n        this.outletDataSubscriptions.set(outlet, dataSubscription);\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RoutedComponentInputBinder, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RoutedComponentInputBinder });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RoutedComponentInputBinder, decorators: [{\r\n            type: Injectable\r\n        }] });\r\nconst provideComponentInputBinding = () => {\r\n    return {\r\n        provide: INPUT_BINDER,\r\n        useFactory: componentInputBindingFactory,\r\n        deps: [Router],\r\n    };\r\n};\r\nfunction componentInputBindingFactory(router) {\r\n    /**\r\n     * We cast the router to any here, since the componentInputBindingEnabled\r\n     * property is not available until Angular v16.\r\n     */\r\n    if (router?.componentInputBindingEnabled) {\r\n        return new RoutedComponentInputBinder();\r\n    }\r\n    return null;\r\n}\r\n\r\nconst BACK_BUTTON_INPUTS = ['color', 'defaultHref', 'disabled', 'icon', 'mode', 'routerAnimation', 'text', 'type'];\r\nlet IonBackButton = class IonBackButton {\r\n    routerOutlet;\r\n    navCtrl;\r\n    config;\r\n    r;\r\n    z;\r\n    el;\r\n    constructor(routerOutlet, navCtrl, config, r, z, c) {\r\n        this.routerOutlet = routerOutlet;\r\n        this.navCtrl = navCtrl;\r\n        this.config = config;\r\n        this.r = r;\r\n        this.z = z;\r\n        c.detach();\r\n        this.el = this.r.nativeElement;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    onClick(ev) {\r\n        const defaultHref = this.defaultHref || this.config.get('backButtonDefaultHref');\r\n        if (this.routerOutlet?.canGoBack()) {\r\n            this.navCtrl.setDirection('back', undefined, undefined, this.routerAnimation);\r\n            this.routerOutlet.pop();\r\n            ev.preventDefault();\r\n        }\r\n        else if (defaultHref != null) {\r\n            this.navCtrl.navigateBack(defaultHref, { animation: this.routerAnimation });\r\n            ev.preventDefault();\r\n        }\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonBackButton, deps: [{ token: IonRouterOutlet, optional: true }, { token: NavController }, { token: Config }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });\r\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonBackButton, inputs: { color: \"color\", defaultHref: \"defaultHref\", disabled: \"disabled\", icon: \"icon\", mode: \"mode\", routerAnimation: \"routerAnimation\", text: \"text\", type: \"type\" }, host: { listeners: { \"click\": \"onClick($event)\" } }, ngImport: i0 });\r\n};\r\nIonBackButton = __decorate([\r\n    ProxyCmp({\r\n        inputs: BACK_BUTTON_INPUTS,\r\n    })\r\n], IonBackButton);\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonBackButton, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\r\n                    inputs: BACK_BUTTON_INPUTS,\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: IonRouterOutlet, decorators: [{\r\n                    type: Optional\r\n                }] }, { type: NavController }, { type: Config }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { onClick: [{\r\n                type: HostListener,\r\n                args: ['click', ['$event']]\r\n            }] } });\r\n\r\n/**\r\n * Adds support for Ionic routing directions and animations to the base Angular router link directive.\r\n *\r\n * When the router link is clicked, the directive will assign the direction and\r\n * animation so that the routing integration will transition correctly.\r\n */\r\nclass RouterLinkDelegateDirective {\r\n    locationStrategy;\r\n    navCtrl;\r\n    elementRef;\r\n    router;\r\n    routerLink;\r\n    routerDirection = 'forward';\r\n    routerAnimation;\r\n    constructor(locationStrategy, navCtrl, elementRef, router, routerLink) {\r\n        this.locationStrategy = locationStrategy;\r\n        this.navCtrl = navCtrl;\r\n        this.elementRef = elementRef;\r\n        this.router = router;\r\n        this.routerLink = routerLink;\r\n    }\r\n    ngOnInit() {\r\n        this.updateTargetUrlAndHref();\r\n    }\r\n    ngOnChanges() {\r\n        this.updateTargetUrlAndHref();\r\n    }\r\n    updateTargetUrlAndHref() {\r\n        if (this.routerLink?.urlTree) {\r\n            const href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\r\n            this.elementRef.nativeElement.href = href;\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    onClick(ev) {\r\n        this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\r\n        /**\r\n         * This prevents the browser from\r\n         * performing a page reload when pressing\r\n         * an Ionic component with routerLink.\r\n         * The page reload interferes with routing\r\n         * and causes ion-back-button to disappear\r\n         * since the local history is wiped on reload.\r\n         */\r\n        ev.preventDefault();\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RouterLinkDelegateDirective, deps: [{ token: i1.LocationStrategy }, { token: NavController }, { token: i0.ElementRef }, { token: i3.Router }, { token: i3.RouterLink, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\r\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: RouterLinkDelegateDirective, selector: \":not(a):not(area)[routerLink]\", inputs: { routerDirection: \"routerDirection\", routerAnimation: \"routerAnimation\" }, host: { listeners: { \"click\": \"onClick($event)\" } }, usesOnChanges: true, ngImport: i0 });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RouterLinkDelegateDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: ':not(a):not(area)[routerLink]',\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i1.LocationStrategy }, { type: NavController }, { type: i0.ElementRef }, { type: i3.Router }, { type: i3.RouterLink, decorators: [{\r\n                    type: Optional\r\n                }] }]; }, propDecorators: { routerDirection: [{\r\n                type: Input\r\n            }], routerAnimation: [{\r\n                type: Input\r\n            }], onClick: [{\r\n                type: HostListener,\r\n                args: ['click', ['$event']]\r\n            }] } });\r\nclass RouterLinkWithHrefDelegateDirective {\r\n    locationStrategy;\r\n    navCtrl;\r\n    elementRef;\r\n    router;\r\n    routerLink;\r\n    routerDirection = 'forward';\r\n    routerAnimation;\r\n    constructor(locationStrategy, navCtrl, elementRef, router, routerLink) {\r\n        this.locationStrategy = locationStrategy;\r\n        this.navCtrl = navCtrl;\r\n        this.elementRef = elementRef;\r\n        this.router = router;\r\n        this.routerLink = routerLink;\r\n    }\r\n    ngOnInit() {\r\n        this.updateTargetUrlAndHref();\r\n    }\r\n    ngOnChanges() {\r\n        this.updateTargetUrlAndHref();\r\n    }\r\n    updateTargetUrlAndHref() {\r\n        if (this.routerLink?.urlTree) {\r\n            const href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\r\n            this.elementRef.nativeElement.href = href;\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    onClick() {\r\n        this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RouterLinkWithHrefDelegateDirective, deps: [{ token: i1.LocationStrategy }, { token: NavController }, { token: i0.ElementRef }, { token: i3.Router }, { token: i3.RouterLink, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\r\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: RouterLinkWithHrefDelegateDirective, selector: \"a[routerLink],area[routerLink]\", inputs: { routerDirection: \"routerDirection\", routerAnimation: \"routerAnimation\" }, host: { listeners: { \"click\": \"onClick()\" } }, usesOnChanges: true, ngImport: i0 });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: RouterLinkWithHrefDelegateDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: 'a[routerLink],area[routerLink]',\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i1.LocationStrategy }, { type: NavController }, { type: i0.ElementRef }, { type: i3.Router }, { type: i3.RouterLink, decorators: [{\r\n                    type: Optional\r\n                }] }]; }, propDecorators: { routerDirection: [{\r\n                type: Input\r\n            }], routerAnimation: [{\r\n                type: Input\r\n            }], onClick: [{\r\n                type: HostListener,\r\n                args: ['click']\r\n            }] } });\r\n\r\nconst NAV_INPUTS = ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'];\r\nconst NAV_METHODS = [\r\n    'push',\r\n    'insert',\r\n    'insertPages',\r\n    'pop',\r\n    'popTo',\r\n    'popToRoot',\r\n    'removeIndex',\r\n    'setRoot',\r\n    'setPages',\r\n    'getActive',\r\n    'getByIndex',\r\n    'canGoBack',\r\n    'getPrevious',\r\n];\r\nlet IonNav = class IonNav {\r\n    z;\r\n    el;\r\n    constructor(ref, environmentInjector, injector, angularDelegate, z, c) {\r\n        this.z = z;\r\n        c.detach();\r\n        this.el = ref.nativeElement;\r\n        ref.nativeElement.delegate = angularDelegate.create(environmentInjector, injector);\r\n        proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonNav, deps: [{ token: i0.ElementRef }, { token: i0.EnvironmentInjector }, { token: i0.Injector }, { token: AngularDelegate }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });\r\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonNav, inputs: { animated: \"animated\", animation: \"animation\", root: \"root\", rootParams: \"rootParams\", swipeGesture: \"swipeGesture\" }, ngImport: i0 });\r\n};\r\nIonNav = __decorate([\r\n    ProxyCmp({\r\n        inputs: NAV_INPUTS,\r\n        methods: NAV_METHODS,\r\n    })\r\n], IonNav);\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonNav, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property\r\n                    inputs: NAV_INPUTS,\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.EnvironmentInjector }, { type: i0.Injector }, { type: AngularDelegate }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; } });\r\n\r\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\r\nclass IonTabs {\r\n    navCtrl;\r\n    tabsInner;\r\n    /**\r\n     * Emitted before the tab view is changed.\r\n     */\r\n    ionTabsWillChange = new EventEmitter();\r\n    /**\r\n     * Emitted after the tab view is changed.\r\n     */\r\n    ionTabsDidChange = new EventEmitter();\r\n    tabBarSlot = 'bottom';\r\n    constructor(navCtrl) {\r\n        this.navCtrl = navCtrl;\r\n    }\r\n    ngAfterContentInit() {\r\n        this.detectSlotChanges();\r\n    }\r\n    ngAfterContentChecked() {\r\n        this.detectSlotChanges();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    onStackWillChange({ enteringView, tabSwitch }) {\r\n        const stackId = enteringView.stackId;\r\n        if (tabSwitch && stackId !== undefined) {\r\n            this.ionTabsWillChange.emit({ tab: stackId });\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    onStackDidChange({ enteringView, tabSwitch }) {\r\n        const stackId = enteringView.stackId;\r\n        if (tabSwitch && stackId !== undefined) {\r\n            if (this.tabBar) {\r\n                this.tabBar.selectedTab = stackId;\r\n            }\r\n            this.ionTabsDidChange.emit({ tab: stackId });\r\n        }\r\n    }\r\n    /**\r\n     * When a tab button is clicked, there are several scenarios:\r\n     * 1. If the selected tab is currently active (the tab button has been clicked\r\n     *    again), then it should go to the root view for that tab.\r\n     *\r\n     *   a. Get the saved root view from the router outlet. If the saved root view\r\n     *      matches the tabRootUrl, set the route view to this view including the\r\n     *      navigation extras.\r\n     *   b. If the saved root view from the router outlet does\r\n     *      not match, navigate to the tabRootUrl. No navigation extras are\r\n     *      included.\r\n     *\r\n     * 2. If the current tab tab is not currently selected, get the last route\r\n     *    view from the router outlet.\r\n     *\r\n     *   a. If the last route view exists, navigate to that view including any\r\n     *      navigation extras\r\n     *   b. If the last route view doesn't exist, then navigate\r\n     *      to the default tabRootUrl\r\n     */\r\n    select(tabOrEvent) {\r\n        const isTabString = typeof tabOrEvent === 'string';\r\n        const tab = isTabString ? tabOrEvent : tabOrEvent.detail.tab;\r\n        const alreadySelected = this.outlet.getActiveStackId() === tab;\r\n        const tabRootUrl = `${this.outlet.tabsPrefix}/${tab}`;\r\n        /**\r\n         * If this is a nested tab, prevent the event\r\n         * from bubbling otherwise the outer tabs\r\n         * will respond to this event too, causing\r\n         * the app to get directed to the wrong place.\r\n         */\r\n        if (!isTabString) {\r\n            tabOrEvent.stopPropagation();\r\n        }\r\n        if (alreadySelected) {\r\n            const activeStackId = this.outlet.getActiveStackId();\r\n            const activeView = this.outlet.getLastRouteView(activeStackId);\r\n            // If on root tab, do not navigate to root tab again\r\n            if (activeView?.url === tabRootUrl) {\r\n                return;\r\n            }\r\n            const rootView = this.outlet.getRootView(tab);\r\n            const navigationExtras = rootView && tabRootUrl === rootView.url && rootView.savedExtras;\r\n            return this.navCtrl.navigateRoot(tabRootUrl, {\r\n                ...navigationExtras,\r\n                animated: true,\r\n                animationDirection: 'back',\r\n            });\r\n        }\r\n        else {\r\n            const lastRoute = this.outlet.getLastRouteView(tab);\r\n            /**\r\n             * If there is a lastRoute, goto that, otherwise goto the fallback url of the\r\n             * selected tab\r\n             */\r\n            const url = lastRoute?.url || tabRootUrl;\r\n            const navigationExtras = lastRoute?.savedExtras;\r\n            return this.navCtrl.navigateRoot(url, {\r\n                ...navigationExtras,\r\n                animated: true,\r\n                animationDirection: 'back',\r\n            });\r\n        }\r\n    }\r\n    getSelected() {\r\n        return this.outlet.getActiveStackId();\r\n    }\r\n    /**\r\n     * Detects changes to the slot attribute of the tab bar.\r\n     *\r\n     * If the slot attribute has changed, then the tab bar\r\n     * should be relocated to the new slot position.\r\n     */\r\n    detectSlotChanges() {\r\n        this.tabBars.forEach((tabBar) => {\r\n            // el is a protected attribute from the generated component wrapper\r\n            const currentSlot = tabBar.el.getAttribute('slot');\r\n            if (currentSlot !== this.tabBarSlot) {\r\n                this.tabBarSlot = currentSlot;\r\n                this.relocateTabBar();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Relocates the tab bar to the new slot position.\r\n     */\r\n    relocateTabBar() {\r\n        /**\r\n         * `el` is a protected attribute from the generated component wrapper.\r\n         * To avoid having to manually create the wrapper for tab bar, we\r\n         * cast the tab bar to any and access the protected attribute.\r\n         */\r\n        const tabBar = this.tabBar.el;\r\n        if (this.tabBarSlot === 'top') {\r\n            /**\r\n             * A tab bar with a slot of \"top\" should be inserted\r\n             * at the top of the container.\r\n             */\r\n            this.tabsInner.nativeElement.before(tabBar);\r\n        }\r\n        else {\r\n            /**\r\n             * A tab bar with a slot of \"bottom\" or without a slot\r\n             * should be inserted at the end of the container.\r\n             */\r\n            this.tabsInner.nativeElement.after(tabBar);\r\n        }\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonTabs, deps: [{ token: NavController }], target: i0.ɵɵFactoryTarget.Directive });\r\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: IonTabs, selector: \"ion-tabs\", outputs: { ionTabsWillChange: \"ionTabsWillChange\", ionTabsDidChange: \"ionTabsDidChange\" }, host: { listeners: { \"ionTabButtonClick\": \"select($event)\" } }, viewQueries: [{ propertyName: \"tabsInner\", first: true, predicate: [\"tabsInner\"], descendants: true, read: ElementRef, static: true }], ngImport: i0 });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: IonTabs, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: 'ion-tabs',\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: NavController }]; }, propDecorators: { tabsInner: [{\r\n                type: ViewChild,\r\n                args: ['tabsInner', { read: ElementRef, static: true }]\r\n            }], ionTabsWillChange: [{\r\n                type: Output\r\n            }], ionTabsDidChange: [{\r\n                type: Output\r\n            }], select: [{\r\n                type: HostListener,\r\n                args: ['ionTabButtonClick', ['$event']]\r\n            }] } });\r\n\r\nconst raf = (h) => {\r\n    if (typeof __zone_symbol__requestAnimationFrame === 'function') {\r\n        return __zone_symbol__requestAnimationFrame(h);\r\n    }\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        return requestAnimationFrame(h);\r\n    }\r\n    return setTimeout(h);\r\n};\r\n\r\n// TODO(FW-2827): types\r\nclass ValueAccessor {\r\n    injector;\r\n    elementRef;\r\n    onChange = () => {\r\n        /**/\r\n    };\r\n    onTouched = () => {\r\n        /**/\r\n    };\r\n    lastValue;\r\n    statusChanges;\r\n    constructor(injector, elementRef) {\r\n        this.injector = injector;\r\n        this.elementRef = elementRef;\r\n    }\r\n    writeValue(value) {\r\n        this.elementRef.nativeElement.value = this.lastValue = value;\r\n        setIonicClasses(this.elementRef);\r\n    }\r\n    /**\r\n     * Notifies the ControlValueAccessor of a change in the value of the control.\r\n     *\r\n     * This is called by each of the ValueAccessor directives when we want to update\r\n     * the status and validity of the form control. For example with text components this\r\n     * is called when the ionInput event is fired. For select components this is called\r\n     * when the ionChange event is fired.\r\n     *\r\n     * This also updates the Ionic form status classes on the element.\r\n     *\r\n     * @param el The component element.\r\n     * @param value The new value of the control.\r\n     */\r\n    handleValueChange(el, value) {\r\n        if (el === this.elementRef.nativeElement) {\r\n            if (value !== this.lastValue) {\r\n                this.lastValue = value;\r\n                this.onChange(value);\r\n            }\r\n            setIonicClasses(this.elementRef);\r\n        }\r\n    }\r\n    _handleBlurEvent(el) {\r\n        if (el === this.elementRef.nativeElement) {\r\n            this.onTouched();\r\n            setIonicClasses(this.elementRef);\r\n        }\r\n    }\r\n    registerOnChange(fn) {\r\n        this.onChange = fn;\r\n    }\r\n    registerOnTouched(fn) {\r\n        this.onTouched = fn;\r\n    }\r\n    setDisabledState(isDisabled) {\r\n        this.elementRef.nativeElement.disabled = isDisabled;\r\n    }\r\n    ngOnDestroy() {\r\n        if (this.statusChanges) {\r\n            this.statusChanges.unsubscribe();\r\n        }\r\n    }\r\n    ngAfterViewInit() {\r\n        let ngControl;\r\n        try {\r\n            ngControl = this.injector.get(NgControl);\r\n        }\r\n        catch {\r\n            /* No FormControl or ngModel binding */\r\n        }\r\n        if (!ngControl) {\r\n            return;\r\n        }\r\n        // Listen for changes in validity, disabled, or pending states\r\n        if (ngControl.statusChanges) {\r\n            this.statusChanges = ngControl.statusChanges.subscribe(() => setIonicClasses(this.elementRef));\r\n        }\r\n        /**\r\n         * TODO FW-2787: Remove this in favor of https://github.com/angular/angular/issues/10887\r\n         * whenever it is implemented.\r\n         */\r\n        const formControl = ngControl.control;\r\n        if (formControl) {\r\n            const methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];\r\n            methodsToPatch.forEach((method) => {\r\n                if (typeof formControl[method] !== 'undefined') {\r\n                    const oldFn = formControl[method].bind(formControl);\r\n                    formControl[method] = (...params) => {\r\n                        oldFn(...params);\r\n                        setIonicClasses(this.elementRef);\r\n                    };\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: ValueAccessor, deps: [{ token: i0.Injector }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\r\n    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.2.12\", type: ValueAccessor, host: { listeners: { \"ionBlur\": \"_handleBlurEvent($event.target)\" } }, ngImport: i0 });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.2.12\", ngImport: i0, type: ValueAccessor, decorators: [{\r\n            type: Directive\r\n        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i0.ElementRef }]; }, propDecorators: { _handleBlurEvent: [{\r\n                type: HostListener,\r\n                args: ['ionBlur', ['$event.target']]\r\n            }] } });\r\nconst setIonicClasses = (element) => {\r\n    raf(() => {\r\n        const input = element.nativeElement;\r\n        const hasValue = input.value != null && input.value.toString().length > 0;\r\n        const classes = getClasses(input);\r\n        setClasses(input, classes);\r\n        const item = input.closest('ion-item');\r\n        if (item) {\r\n            if (hasValue) {\r\n                setClasses(item, [...classes, 'item-has-value']);\r\n            }\r\n            else {\r\n                setClasses(item, classes);\r\n            }\r\n        }\r\n    });\r\n};\r\nconst getClasses = (element) => {\r\n    const classList = element.classList;\r\n    const classes = [];\r\n    for (let i = 0; i < classList.length; i++) {\r\n        const item = classList.item(i);\r\n        if (item !== null && startsWith(item, 'ng-')) {\r\n            classes.push(`ion-${item.substring(3)}`);\r\n        }\r\n    }\r\n    return classes;\r\n};\r\nconst setClasses = (element, classes) => {\r\n    const classList = element.classList;\r\n    classList.remove('ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine');\r\n    classList.add(...classes);\r\n};\r\nconst startsWith = (input, search) => {\r\n    return input.substring(0, search.length) === search;\r\n};\r\n\r\n/**\r\n * Provides a way to customize when activated routes get reused.\r\n */\r\nclass IonicRouteStrategy {\r\n    /**\r\n     * Whether the given route should detach for later reuse.\r\n     */\r\n    shouldDetach(_route) {\r\n        return false;\r\n    }\r\n    /**\r\n     * Returns `false`, meaning the route (and its subtree) is never reattached\r\n     */\r\n    shouldAttach(_route) {\r\n        return false;\r\n    }\r\n    /**\r\n     * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\r\n     */\r\n    store(_route, _detachedTree) {\r\n        return;\r\n    }\r\n    /**\r\n     * Returns `null` because this strategy does not store routes for later re-use.\r\n     */\r\n    retrieve(_route) {\r\n        return null;\r\n    }\r\n    /**\r\n     * Determines if a route should be reused.\r\n     * This strategy returns `true` when the future route config and\r\n     * current route config are identical and all route parameters are identical.\r\n     */\r\n    shouldReuseRoute(future, curr) {\r\n        if (future.routeConfig !== curr.routeConfig) {\r\n            return false;\r\n        }\r\n        // checking router params\r\n        const futureParams = future.params;\r\n        const currentParams = curr.params;\r\n        const keysA = Object.keys(futureParams);\r\n        const keysB = Object.keys(currentParams);\r\n        if (keysA.length !== keysB.length) {\r\n            return false;\r\n        }\r\n        // Test for A's keys different from B.\r\n        for (const key of keysA) {\r\n            if (currentParams[key] !== futureParams[key]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n// TODO(FW-2827): types\r\nclass OverlayBaseController {\r\n    ctrl;\r\n    constructor(ctrl) {\r\n        this.ctrl = ctrl;\r\n    }\r\n    /**\r\n     * Creates a new overlay\r\n     */\r\n    create(opts) {\r\n        return this.ctrl.create((opts || {}));\r\n    }\r\n    /**\r\n     * When `id` is not provided, it dismisses the top overlay.\r\n     */\r\n    dismiss(data, role, id) {\r\n        return this.ctrl.dismiss(data, role, id);\r\n    }\r\n    /**\r\n     * Returns the top overlay.\r\n     */\r\n    getTop() {\r\n        return this.ctrl.getTop();\r\n    }\r\n}\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { AngularDelegate, Config, ConfigToken, DomController, IonBackButton, IonModal, IonNav, IonPopover, IonRouterOutlet, IonTabs, IonicRouteStrategy, MenuController, NavController, NavParams, OverlayBaseController, Platform, ProxyCmp, RouterLinkDelegateDirective, RouterLinkWithHrefDelegateDirective, ValueAccessor, bindLifecycleEvents, provideComponentInputBinding, raf, setIonicClasses };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { map, switchMap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/fire/compat/firestore\";\nexport class FirebaseService {\n  constructor(firestore) {\n    this.firestore = firestore;\n    this.restaurantId = 'restaurante1'; // ID do restaurante no Firestore\n  }\n  // Adicionar reserva ao Firestore\n  addReserva(reserva) {\n    return this.verificarDisponibilidade(reserva.tipoMesa).pipe(switchMap(disponivel => {\n      if (!disponivel) {\n        throw new Error('Não há mesas disponíveis para este tipo');\n      }\n      return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('reservas').add(reserva);\n    })).toPromise();\n  }\n  // Obter todas as reservas do Firestore\n  getReservas() {\n    return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('reservas').valueChanges({\n      idField: 'id'\n    });\n  }\n  // Obter limite de mesas do Firestore\n  getLimiteMesas() {\n    return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('limiteMesas').valueChanges();\n  }\n  // Verificar se há mesas disponíveis para reserva\n  verificarDisponibilidade(tipoMesa) {\n    return this.getLimiteMesas().pipe(switchMap(limites => {\n      const limite = limites.find(l => l.tipo === tipoMesa);\n      if (!limite) {\n        throw new Error('Tipo de mesa não encontrado');\n      }\n      // Obter todas as reservas para o tipo de mesa específico\n      return this.getReservas().pipe(map(reservas => {\n        // Contar o número de reservas para o tipo de mesa\n        const reservasTipoMesa = reservas.filter(r => r.tipoMesa === tipoMesa).length;\n        // Comparar com o limite definido\n        if (reservasTipoMesa < limite.limite) {\n          return true; // Há mesas disponíveis\n        } else {\n          return false; // Não há mesas disponíveis\n        }\n      }));\n    }));\n  }\n  static #_ = this.ɵfac = function FirebaseService_Factory(t) {\n    return new (t || FirebaseService)(i0.ɵɵinject(i1.AngularFirestore));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FirebaseService,\n    factory: FirebaseService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["map","switchMap","FirebaseService","constructor","firestore","restaurantId","addReserva","reserva","verificarDisponibilidade","tipoMesa","pipe","disponivel","Error","collection","doc","add","toPromise","getReservas","valueChanges","idField","getLimiteMesas","limites","limite","find","l","tipo","reservas","reservasTipoMesa","filter","r","length","_","i0","ɵɵinject","i1","AngularFirestore","_2","factory","ɵfac","providedIn"],"sources":["C:\\Users\\enzod\\integrador-07_07\\Integrador_reservas\\src\\app\\firebase.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { AngularFirestore } from '@angular/fire/compat/firestore';\r\nimport { Observable } from 'rxjs';\r\nimport { map, switchMap } from 'rxjs/operators';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class FirebaseService {\r\n\r\n  private restaurantId = 'restaurante1'; // ID do restaurante no Firestore\r\n\r\n  constructor(private firestore: AngularFirestore) { }\r\n\r\n  // Adicionar reserva ao Firestore\r\n  addReserva(reserva: any): Promise<any> {\r\n    return this.verificarDisponibilidade(reserva.tipoMesa).pipe(\r\n      switchMap(disponivel => {\r\n        if (!disponivel) {\r\n          throw new Error('Não há mesas disponíveis para este tipo');\r\n        }\r\n        return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('reservas').add(reserva);\r\n      })\r\n    ).toPromise();\r\n  }\r\n\r\n  // Obter todas as reservas do Firestore\r\n  getReservas(): Observable<any[]> {\r\n    return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('reservas').valueChanges({ idField: 'id' });\r\n  }\r\n\r\n  // Obter limite de mesas do Firestore\r\n  getLimiteMesas(): Observable<any[]> {\r\n    return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('limiteMesas').valueChanges();\r\n  }\r\n\r\n  // Verificar se há mesas disponíveis para reserva\r\n  verificarDisponibilidade(tipoMesa: string): Observable<boolean> {\r\n    return this.getLimiteMesas().pipe(\r\n      switchMap((limites: any[]) => {\r\n        const limite = limites.find(l => l.tipo === tipoMesa);\r\n        if (!limite) {\r\n          throw new Error('Tipo de mesa não encontrado');\r\n        }\r\n\r\n        // Obter todas as reservas para o tipo de mesa específico\r\n        return this.getReservas().pipe(\r\n          map((reservas: any[]) => {\r\n            // Contar o número de reservas para o tipo de mesa\r\n            const reservasTipoMesa = reservas.filter(r => r.tipoMesa === tipoMesa).length;\r\n            \r\n            // Comparar com o limite definido\r\n            if (reservasTipoMesa < limite.limite) {\r\n              return true; // Há mesas disponíveis\r\n            } else {\r\n              return false; // Não há mesas disponíveis\r\n            }\r\n          })\r\n        );\r\n      })\r\n    );\r\n  }\r\n\r\n}\r\n"],"mappings":"AAGA,SAASA,GAAG,EAAEC,SAAS,QAAQ,gBAAgB;;;AAK/C,OAAM,MAAOC,eAAe;EAI1BC,YAAoBC,SAA2B;IAA3B,KAAAA,SAAS,GAATA,SAAS;IAFrB,KAAAC,YAAY,GAAG,cAAc,CAAC,CAAC;EAEY;EAEnD;EACAC,UAAUA,CAACC,OAAY;IACrB,OAAO,IAAI,CAACC,wBAAwB,CAACD,OAAO,CAACE,QAAQ,CAAC,CAACC,IAAI,CACzDT,SAAS,CAACU,UAAU,IAAG;MACrB,IAAI,CAACA,UAAU,EAAE;QACf,MAAM,IAAIC,KAAK,CAAC,yCAAyC,CAAC;MAC5D;MACA,OAAO,IAAI,CAACR,SAAS,CAACS,UAAU,CAAC,cAAc,CAAC,CAACC,GAAG,CAAC,IAAI,CAACT,YAAY,CAAC,CAACQ,UAAU,CAAC,UAAU,CAAC,CAACE,GAAG,CAACR,OAAO,CAAC;IAC7G,CAAC,CAAC,CACH,CAACS,SAAS,EAAE;EACf;EAEA;EACAC,WAAWA,CAAA;IACT,OAAO,IAAI,CAACb,SAAS,CAACS,UAAU,CAAC,cAAc,CAAC,CAACC,GAAG,CAAC,IAAI,CAACT,YAAY,CAAC,CAACQ,UAAU,CAAC,UAAU,CAAC,CAACK,YAAY,CAAC;MAAEC,OAAO,EAAE;IAAI,CAAE,CAAC;EAChI;EAEA;EACAC,cAAcA,CAAA;IACZ,OAAO,IAAI,CAAChB,SAAS,CAACS,UAAU,CAAC,cAAc,CAAC,CAACC,GAAG,CAAC,IAAI,CAACT,YAAY,CAAC,CAACQ,UAAU,CAAC,aAAa,CAAC,CAACK,YAAY,EAAE;EAClH;EAEA;EACAV,wBAAwBA,CAACC,QAAgB;IACvC,OAAO,IAAI,CAACW,cAAc,EAAE,CAACV,IAAI,CAC/BT,SAAS,CAAEoB,OAAc,IAAI;MAC3B,MAAMC,MAAM,GAAGD,OAAO,CAACE,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAKhB,QAAQ,CAAC;MACrD,IAAI,CAACa,MAAM,EAAE;QACX,MAAM,IAAIV,KAAK,CAAC,6BAA6B,CAAC;MAChD;MAEA;MACA,OAAO,IAAI,CAACK,WAAW,EAAE,CAACP,IAAI,CAC5BV,GAAG,CAAE0B,QAAe,IAAI;QACtB;QACA,MAAMC,gBAAgB,GAAGD,QAAQ,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACpB,QAAQ,KAAKA,QAAQ,CAAC,CAACqB,MAAM;QAE7E;QACA,IAAIH,gBAAgB,GAAGL,MAAM,CAACA,MAAM,EAAE;UACpC,OAAO,IAAI,CAAC,CAAC;QACf,CAAC,MAAM;UACL,OAAO,KAAK,CAAC,CAAC;QAChB;MACF,CAAC,CAAC,CACH;IACH,CAAC,CAAC,CACH;EACH;EAAC,QAAAS,CAAA,G;qBArDU7B,eAAe,EAAA8B,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,gBAAA;EAAA;EAAA,QAAAC,EAAA,G;WAAflC,eAAe;IAAAmC,OAAA,EAAfnC,eAAe,CAAAoC,IAAA;IAAAC,UAAA,EAFd;EAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
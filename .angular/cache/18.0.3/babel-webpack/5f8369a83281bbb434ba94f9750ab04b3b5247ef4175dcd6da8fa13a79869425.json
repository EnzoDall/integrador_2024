{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/fire/compat/firestore\";\nexport class FirebaseService {\n  constructor(firestore) {\n    this.firestore = firestore;\n    this.restaurantId = 'restaurante1'; // ID do restaurante no Firestore\n  }\n  // Obter limite de mesas do Firestore\n  getLimiteMesas() {\n    return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('limiteMesas').valueChanges();\n  }\n  // Verificar se há mesas disponíveis para reserva\n  verificarDisponibilidade(tipoMesa) {\n    return this.getLimiteMesas().pipe(map(limites => {\n      const limite = limites.find(l => l.tipo === tipoMesa);\n      if (!limite) {\n        throw new Error('Tipo de mesa não encontrado');\n      }\n      // Aqui você pode implementar a lógica para verificar se ainda há mesas disponíveis\n      // Comparar com o número de reservas existentes\n      return true; // Retornar true se houver mesas disponíveis, false caso contrário\n    }));\n  }\n  // Adicionar reserva ao Firestore\n  addReserva(reserva) {\n    return this.verificarDisponibilidade(reserva.tipoMesa).pipe(switchMap(disponivel => {\n      if (!disponivel) {\n        throw new Error('Não há mesas disponíveis para este tipo');\n      }\n      return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('reservas').add(reserva);\n    })).toPromise();\n  }\n  static #_ = this.ɵfac = function FirebaseService_Factory(t) {\n    return new (t || FirebaseService)(i0.ɵɵinject(i1.AngularFirestore));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FirebaseService,\n    factory: FirebaseService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["FirebaseService","constructor","firestore","restaurantId","getLimiteMesas","collection","doc","valueChanges","verificarDisponibilidade","tipoMesa","pipe","map","limites","limite","find","l","tipo","Error","addReserva","reserva","switchMap","disponivel","add","toPromise","_","i0","ɵɵinject","i1","AngularFirestore","_2","factory","ɵfac","providedIn"],"sources":["C:\\Users\\enzod\\integrador-07_07\\Integrador_reservas\\src\\app\\firebase.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { AngularFirestore } from '@angular/fire/compat/firestore';\r\nimport { Observable } from 'rxjs';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class FirebaseService {\r\n\r\n  private restaurantId = 'restaurante1'; // ID do restaurante no Firestore\r\n\r\n  constructor(private firestore: AngularFirestore) { }\r\n\r\n  // Obter limite de mesas do Firestore\r\n  getLimiteMesas(): Observable<any> {\r\n    return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('limiteMesas').valueChanges();\r\n  }\r\n\r\n  // Verificar se há mesas disponíveis para reserva\r\n  verificarDisponibilidade(tipoMesa: string): Observable<boolean> {\r\n    return this.getLimiteMesas().pipe(\r\n      map((limites: any[]) => {\r\n        const limite = limites.find(l => l.tipo === tipoMesa);\r\n        if (!limite) {\r\n          throw new Error('Tipo de mesa não encontrado');\r\n        }\r\n\r\n        // Aqui você pode implementar a lógica para verificar se ainda há mesas disponíveis\r\n        // Comparar com o número de reservas existentes\r\n\r\n        return true; // Retornar true se houver mesas disponíveis, false caso contrário\r\n      })\r\n    );\r\n  }\r\n\r\n  // Adicionar reserva ao Firestore\r\n  addReserva(reserva: any): Promise<any> {\r\n    return this.verificarDisponibilidade(reserva.tipoMesa).pipe(\r\n      switchMap(disponivel => {\r\n        if (!disponivel) {\r\n          throw new Error('Não há mesas disponíveis para este tipo');\r\n        }\r\n        return this.firestore.collection('restaurantes').doc(this.restaurantId).collection('reservas').add(reserva);\r\n      })\r\n    ).toPromise();\r\n  }\r\n\r\n}\r\n"],"mappings":";;AAOA,OAAM,MAAOA,eAAe;EAI1BC,YAAoBC,SAA2B;IAA3B,KAAAA,SAAS,GAATA,SAAS;IAFrB,KAAAC,YAAY,GAAG,cAAc,CAAC,CAAC;EAEY;EAEnD;EACAC,cAAcA,CAAA;IACZ,OAAO,IAAI,CAACF,SAAS,CAACG,UAAU,CAAC,cAAc,CAAC,CAACC,GAAG,CAAC,IAAI,CAACH,YAAY,CAAC,CAACE,UAAU,CAAC,aAAa,CAAC,CAACE,YAAY,EAAE;EAClH;EAEA;EACAC,wBAAwBA,CAACC,QAAgB;IACvC,OAAO,IAAI,CAACL,cAAc,EAAE,CAACM,IAAI,CAC/BC,GAAG,CAAEC,OAAc,IAAI;MACrB,MAAMC,MAAM,GAAGD,OAAO,CAACE,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAKP,QAAQ,CAAC;MACrD,IAAI,CAACI,MAAM,EAAE;QACX,MAAM,IAAII,KAAK,CAAC,6BAA6B,CAAC;MAChD;MAEA;MACA;MAEA,OAAO,IAAI,CAAC,CAAC;IACf,CAAC,CAAC,CACH;EACH;EAEA;EACAC,UAAUA,CAACC,OAAY;IACrB,OAAO,IAAI,CAACX,wBAAwB,CAACW,OAAO,CAACV,QAAQ,CAAC,CAACC,IAAI,CACzDU,SAAS,CAACC,UAAU,IAAG;MACrB,IAAI,CAACA,UAAU,EAAE;QACf,MAAM,IAAIJ,KAAK,CAAC,yCAAyC,CAAC;MAC5D;MACA,OAAO,IAAI,CAACf,SAAS,CAACG,UAAU,CAAC,cAAc,CAAC,CAACC,GAAG,CAAC,IAAI,CAACH,YAAY,CAAC,CAACE,UAAU,CAAC,UAAU,CAAC,CAACiB,GAAG,CAACH,OAAO,CAAC;IAC7G,CAAC,CAAC,CACH,CAACI,SAAS,EAAE;EACf;EAAC,QAAAC,CAAA,G;qBAtCUxB,eAAe,EAAAyB,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,gBAAA;EAAA;EAAA,QAAAC,EAAA,G;WAAf7B,eAAe;IAAA8B,OAAA,EAAf9B,eAAe,CAAA+B,IAAA;IAAAC,UAAA,EAFd;EAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}